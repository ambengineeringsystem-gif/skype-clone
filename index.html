<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E📞%3C/text%3E%3C/svg%3E" />
  <title>Dialer — WebRTC P2P Calls</title>
  <!-- Hidden audio for ringing -->
  <audio id="ringAudio" src="ring.mp3" loop preload="auto"></audio>
  <style>
    :root{--bg:#081620;--card:#06121a;--muted:#9aa6b2;--accent:#06b6d4;--accent-2:#10b981}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#021226 0%, #03111a 100%);color:#e6eef6;-webkit-font-smoothing:antialiased}
    .app{max-width:980px;margin:12px auto;padding:10px}
    header{display:flex;align-items:center;gap:12px;justify-content:space-between}
    h1{margin:0;font-size:1.05rem}
    .subtitle{font-size:0.9rem;color:var(--muted)}

    /* Desktop two-column, mobile stacked */
    .grid{display:grid;grid-template-columns:320px 1fr;gap:12px;margin-top:12px}
    .panel{background:rgba(255,255,255,0.02);padding:12px;border-radius:12px}
    label{font-size:0.85rem;color:var(--muted);display:block;margin-bottom:8px}
    input[type=text]{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}

    /* Dialer-style buttons */
    .callBtn{width:54px;height:54px;border-radius:50%;display:inline-flex;align-items:center;justify-content:center;border:0;cursor:pointer;font-weight:700}
    .callBtn.video{background:linear-gradient(180deg,var(--accent),#058b9a);color:#002b2f}
    .callBtn.audio{background:linear-gradient(180deg,var(--accent-2),#0f9a6d);color:#062a18}
    .callBtn.reject{background:#ef4444;color:white}

    .usersList{max-height:54vh;overflow:auto;margin-top:8px}
    .userRow{display:flex;align-items:center;justify-content:space-between;padding:10px;border-radius:10px;margin-bottom:8px;background:linear-gradient(90deg,rgba(255,255,255,0.01),transparent)}
    .userMeta{display:flex;gap:12px;align-items:center}
    .avatar{width:44px;height:44px;border-radius:50%;background:linear-gradient(135deg,#062b3a,#083047);display:flex;align-items:center;justify-content:center;font-weight:700}
    .dot{width:12px;height:12px;border-radius:50%;box-shadow:0 0 0 4px rgba(0,0,0,0.35)}
    .dot.online{background:#2dd4bf}
    .dot.offline{background:#374151}
    .small{font-size:0.85rem;color:var(--muted)}

  .videoStage{position:relative;height:68vh;border-radius:12px;overflow:hidden;background:#000;display:flex;align-items:center;justify-content:center}
    video{width:100%;height:100%;object-fit:cover;background:#000}
  .localPreview{position:absolute;right:14px;bottom:14px;width:120px;height:90px;border-radius:10px;overflow:hidden;border:2px solid rgba(255,255,255,0.05);box-shadow:0 6px 20px rgba(0,0,0,0.6);background:#000}

  /* in-call overlay controls (mute/hangup) */
  .stageControls{position:absolute;left:50%;transform:translateX(-50%);bottom:22px;display:none;gap:14px;align-items:center;z-index:1001}
  .stageBtn{width:60px;height:60px;border-radius:50%;border:0;display:flex;align-items:center;justify-content:center;font-size:20px;cursor:pointer;box-shadow:0 8px 24px rgba(0,0,0,0.6)}
  .stageBtn.hangup{background:#ef4444;color:white}
  .stageBtn.mute{background:rgba(0,0,0,0.45);color:white;border:1px solid rgba(255,255,255,0.06)}
  @media (max-width:640px){ .stageBtn{width:56px;height:56px;font-size:18px} }

  /* fullscreen / in-call styles */
  .videoStage.fullscreen{position:fixed;left:0;top:0;right:0;bottom:0;z-index:9999}
  .videoStage.fullscreen video{width:100%;height:100%;object-fit:cover}
  .videoStage.fullscreen .localPreview{width:140px;height:110px;right:18px;bottom:18px;border-radius:12px}

  /* incoming call modal buttons - improved visuals */
  .callAction{padding:12px 16px;border-radius:12px;border:0;color:white;cursor:pointer;font-weight:700;font-size:1rem}
  .callAction.acceptVid{background:linear-gradient(180deg,#10b981,#059669)}
  .callAction.acceptAud{background:linear-gradient(180deg,#f59e0b,#d97706)}
  .callAction.reject{background:#ef4444}
  .callAction svg{vertical-align:middle;margin-right:8px}

    .controls{display:flex;gap:10px;margin-top:10px;align-items:center}
    .statusPill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02);font-size:0.9rem}

    .modal{position:fixed;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(0,0,0,0.45),rgba(0,0,0,0.6))}
    .card{background:var(--card);padding:18px;border-radius:14px;min-width:260px;text-align:center;box-shadow:0 10px 30px rgba(2,6,23,0.7);border:2px solid #333}

    /* Mobile modal adjustments */
    @media (max-width:640px){
      .card{padding:30px;font-size:1.2rem;min-width:300px}
    }
    .card h2{margin:0 0 6px}
    .muted{color:var(--muted)}
    footer{margin-top:12px;color:var(--muted);font-size:0.82rem}

    /* Mobile adjustments: stack and enlarge buttons */
    @media (max-width:640px){
      .app{padding:10px 12px}
      .grid{grid-template-columns:1fr;}
      .panel{padding:12px}
      .videoStage{height:70vh}
      .localPreview{width:108px;height:80px;right:10px;bottom:10px}
      .callBtn{width:64px;height:64px}
      .userRow{padding:12px}
      .avatar{width:52px;height:52px}
    }

    /* Tiny screens: emphasize dialer feeling */
    @media (max-width:420px){
      header{flex-direction:column;align-items:flex-start;gap:6px}
      .subtitle{font-size:0.82rem}
      .usersList{max-height:28vh}
      .videoStage{height:85vh}
      .callBtn{width:72px;height:72px}
      .controls{justify-content:space-between}
      .statusPill{flex:1;text-align:center}
    }
      /* Messenger-specific polish */
      #pageMessenger { color: #dbeef6; }
      #messengerContacts { background: rgba(255,255,255,0.01); }
      #messengerContacts button.messengerContactBtn{ color: #c7eaf0; background: transparent; border: 1px solid transparent; }
      #messengerContacts button.messengerContactBtn:hover{ background: rgba(255,255,255,0.02); color: #fff; }
      #messengerContacts button.messengerContactBtn.selected{ background: linear-gradient(90deg, rgba(6,182,212,0.12), rgba(16,185,129,0.06)); border-left:4px solid var(--accent); padding-left:10px; color: #fff; }
      #messagesList{ background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); border-radius:10px; }
      #messagesList .msg-row{ margin-bottom:10px; display:flex; }
      .msg-bubble{ max-width:70%; padding:10px 12px; border-radius:14px; box-shadow: 0 4px 14px rgba(2,6,23,0.6); font-size:0.98rem; line-height:1.2 }
      .msg-bubble.mine{ background: linear-gradient(180deg,#06b6d4,#028a9a); color:#002b2f; border-bottom-right-radius:4px; }
      .msg-bubble.their{ background: rgba(255,255,255,0.03); color:#e6eef6; border-bottom-left-radius:4px; }
      .msg-meta{ font-size:0.78rem; color:var(--muted); margin-top:6px }
      #msgInput{ border:1px solid rgba(255,255,255,0.06); background: rgba(0,0,0,0.25); color:inherit; }
      #sendMsgBtn{ padding:10px 14px; border-radius:10px; }
      /* scrollbar for messages and contacts */
      #messagesList::-webkit-scrollbar, #messengerContacts::-webkit-scrollbar{ height:10px; width:10px }
      #messagesList::-webkit-scrollbar-thumb, #messengerContacts::-webkit-scrollbar-thumb{ background: rgba(255,255,255,0.04); border-radius:10px }
      #messagesList::-webkit-scrollbar-track, #messengerContacts::-webkit-scrollbar-track{ background: transparent }
    #chatWith{ font-weight:700; color:#e6f7fb; }
    #chatStatus{ color:var(--muted); font-size:0.85rem }
    /* fullscreen & minimized states */
    #pageMessenger.pm-fullscreen{ position:fixed; left:0; top:0; right:0; bottom:0; z-index:120000; padding:22px; background:linear-gradient(180deg,#021226 0%, #03111a 100%); }
  #pageMessenger.pm-fullscreen .appGrid, #pageMessenger.pm-fullscreen .leftPages{ display:block }
  /* hide contacts and keep only chat area in fullscreen */
  #pageMessenger.pm-fullscreen #messengerContacts{ display:none !important }
  #pageMessenger.pm-fullscreen .panel, #pageMessenger.pm-fullscreen .toolbar, #pageMessenger.pm-fullscreen .sysBar{ display:none }
  /* minimized state removed */
    /* make contact buttons easier to see on very dark background */
  #messengerContacts .messengerContactBtn{ text-align:left; padding:10px; color:#bfeff6; display:flex;align-items:center;gap:12px;border-radius:8px;border:0 }
  #messengerContacts .messengerContactBtn:hover{ color:#fff; background:rgba(255,255,255,0.02) }
  .wa-contacts-list .avatar-small{ width:44px;height:44px;border-radius:50%;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#062b3a,#083047);color:#c7eaf0;font-weight:700 }
  .wa-contacts-list .contact-meta{ display:flex;flex-direction:column;align-items:flex-start }
  .wa-contacts-list .contact-name{ font-weight:600 }
  .wa-contacts-list .contact-sub{ font-size:0.85rem;color:var(--muted) }
  /* WhatsApp-like chat styles */
  .wa-chat { background: transparent; }
  .wa-chat-header{ background:transparent }
  .wa-messages{ background:linear-gradient(180deg, rgba(255,255,255,0.005), rgba(255,255,255,0.00)); }
  .wa-input-bar input{ border-radius:20px }
  .wa-messages .date-sep{ text-align:center;margin:12px 0;color:var(--muted);font-size:0.82rem }
  /* unread badge */
  .contact-badge{ min-width:20px; height:20px; padding:2px 6px; border-radius:10px; background:var(--accent); color:#002b2f; font-weight:700; font-size:0.75rem; display:inline-flex; align-items:center; justify-content:center }
  .messenger-global-badge{ position:absolute; right:6px; top:6px; min-width:20px; height:20px; padding:2px 6px; border-radius:12px; background:#ef4444; color:white; font-weight:700; font-size:0.75rem }
    #chatWith{ font-weight:700; color:#e6f7fb; }
    #chatStatus{ color:var(--muted); font-size:0.85rem }
    /* make contact buttons easier to see on very dark background */
    #messengerContacts .messengerContactBtn{ text-align:left; padding:10px; color:#bfeff6 }
    #messengerContacts .messengerContactBtn:hover{ color:#fff }
      /* toolbar + bottom nav */
    .toolbar{background:transparent;padding:6px 4px;position:relative}
    /* Signal strength widget (top-right) */
    .signal{display:flex;gap:4px;align-items:flex-end;height:20px}
    .signal .bar{width:6px;border-radius:3px;background:rgba(255,255,255,0.06);transition:background 160ms,height 160ms;display:inline-block}
    .signal .bar:nth-child(1){height:6px}
    .signal .bar:nth-child(2){height:10px}
    .signal .bar:nth-child(3){height:14px}
    .signal .bar:nth-child(4){height:18px}
    .signal .bar.active{background:linear-gradient(180deg,var(--accent),#058b9a)}
    .signalWrapper{position:absolute;right:12px;top:8px;z-index:12000}
  .sysBack{background:rgba(255,255,255,0.02);border:0;border-radius:10px;padding:8px 12px;font-size:18px}
  .sysHome{background:rgba(255,255,255,0.06);border:0;width:44px;height:44px;border-radius:50%;font-size:18px;display:flex;align-items:center;justify-content:center}
  .sysBar{position:fixed;left:0;right:0;bottom:calc(12px + env(safe-area-inset-bottom));display:flex;justify-content:center;gap:24px;z-index:10001;padding-bottom:env(safe-area-inset-bottom)}
      .appIcon{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;padding:16px;display:flex;flex-direction:column;align-items:center;justify-content:center;border:0;cursor:pointer}
  .bottomNav{display:none}
  /* app grid */
  .leftPages{height:calc(100vh - 160px);overflow:auto}
  .appGrid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;padding:12px;grid-auto-rows:1fr}
  .appIcon{aspect-ratio:1/1;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;padding:8px;display:flex;flex-direction:column;align-items:center;justify-content:center;border:0;cursor:pointer;font-size:18px}
  .appIcon .small{margin-top:6px}
  /* On-screen dialer styles */
  .dialerOverlay{position:fixed;left:0;top:0;width:100vw;height:100vh;background:linear-gradient(180deg,rgba(2,6,23,0.9),rgba(2,6,23,0.95));display:none;align-items:center;justify-content:center;z-index:12000}
  .dialerCard{background:var(--card);padding:18px;border-radius:14px;width:92%;max-width:420px;color:var(--muted);box-shadow:0 10px 30px rgba(2,6,23,0.7);}
  .dialDisplay{font-size:1.4rem;padding:12px;border-radius:10px;background:rgba(255,255,255,0.03);text-align:center;letter-spacing:3px;color:var(--accent);margin-bottom:12px}
  .keypad{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
  .key{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:16px;border-radius:12px;text-align:center;font-size:1.2rem;color:white;border:0}
  .key.action{background:linear-gradient(180deg,#10b981,#059669);font-weight:700}
  .key.del{background:linear-gradient(180deg,#ef4444,#dc2626)}
  .dialActions{display:flex;gap:8px;margin-top:12px;justify-content:space-between}
  .dialerMenu{position:absolute;right:14px;top:14px;background:var(--card);border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,0.5);overflow:hidden;display:none}
  .dialerMenu button{display:block;padding:10px 14px;border:0;background:transparent;color:var(--muted);width:200px;text-align:left}
  .dialerMenu button:hover{background:rgba(255,255,255,0.03);color:white}
  /* add-contact modal inside dialer */
  .smallModal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:12500;background:var(--card);padding:16px;border-radius:12px;min-width:260px;max-width:92%;box-shadow:0 8px 30px rgba(0,0,0,0.6);display:none}
  .smallModal input{width:100%;padding:8px;margin-top:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  @media (max-width:640px){ .leftPages{height:calc(100vh - 120px)} }
  </style>
</head>
<body>
  <div id="authContainer" style="display:block; position:fixed; left:0; top:0; width:100%; height:100%; background:linear-gradient(180deg,#021226 0%, #03111a 100%); display:flex; align-items:center; justify-content:center; z-index:1000">
    <div id="authForm" style="background:var(--card); padding:20px; border-radius:14px; min-width:300px; text-align:center; box-shadow:0 10px 30px rgba(2,6,23,0.7)">
      <h2 style="margin:0 0 16px; color:#e6eef6">Welcome</h2>
      <label for="username">Username</label>
      <input id="username" placeholder="Enter username" style="width:100%; padding:10px; margin:8px 0; border-radius:8px; border:1px solid rgba(255,255,255,0.1); background:rgba(255,255,255,0.05); color:#e6eef6" />
      <label for="password" style="margin-top:8px">Password</label>
      <input id="password" type="password" placeholder="Enter password" style="width:100%; padding:10px; margin:8px 0; border-radius:8px; border:1px solid rgba(255,255,255,0.1); background:rgba(255,255,255,0.05); color:#e6eef6" />
      <div style="display:flex;gap:8px;margin-top:16px">
        <button id="registerBtn" style="flex:1; padding:10px; border-radius:8px; border:0; background:linear-gradient(180deg,#06b6d4,#028a9a); color:#002b2f; font-weight:600">Register</button>
        <button id="loginBtn" style="flex:1; padding:10px; border-radius:8px; border:0; background:linear-gradient(180deg,#10b981,#059669); color:#062a18; font-weight:600">Login</button>
      </div>
    </div>
  </div>

  <div id="mainApp" style="display:none">
  <div class="app">
    <!-- Top toolbar (phone-like) -->
    <div class="toolbar" style="margin-top:10px;display:flex;align-items:center;gap:8px;justify-content:center;position:relative">
      <div id="pageTitle" style="font-weight:700">Contacts</div>
      <div class="signalWrapper" aria-hidden="true" style="display:none">
        <div id="signalBars" class="signal" title="Signal strength">
          <div class="bar" data-index="1"></div>
          <div class="bar" data-index="2"></div>
          <div class="bar" data-index="3"></div>
          <div class="bar" data-index="4"></div>
        </div>
      </div>
      <!-- Notification bell: shows global unread count -->
      <button id="notifBell" title="Notifications" style="position:absolute;right:12px;top:8px;background:transparent;border:0;color:inherit;cursor:pointer;font-size:18px;display:flex;align-items:center;gap:8px">
        🔔
        <span id="notifBadge" class="messenger-global-badge" style="display:none">0</span>
      </button>
      <div id="notifPanel" style="position:absolute;right:12px;top:44px;min-width:260px;background:var(--card);border-radius:10px;padding:8px;box-shadow:0 8px 32px rgba(0,0,0,0.6);display:none;z-index:12005">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <strong>Notifications</strong>
          <button id="notifClearAll" style="background:transparent;border:0;color:var(--muted);cursor:pointer">Clear</button>
        </div>
        <div id="notifList" style="max-height:260px;overflow:auto;color:inherit">No notifications</div>
      </div>
    </div>

  <div class="grid">
        <!-- Pages: Home (app-icon grid), Contacts, Dialer, History, Profile -->
        <div class="leftPages">
          <section id="pageHome" class="page">
            <div class="appGrid">
              <button class="appIcon" data-target="contacts">📇<div class="small">Contacts</div></button>
              <button class="appIcon" data-target="dial">📞<div class="small">Call</div></button>
              <button class="appIcon" data-target="history">🕘<div class="small">History</div></button>
              <button class="appIcon" data-target="profile">👤<div class="small">Profile</div></button>
              <button class="appIcon" data-target="settings">⚙️<div class="small">Settings</div></button>
            <button class="appIcon" data-target="messenger">💬<div class="small">Messenger</div></button>
              <!-- placeholders to fill 3x3 grid -->
              <div></div><div></div><div></div>
            </div>
            <!-- Home dialer overlay -->
            <div id="homeDialer" class="dialerOverlay" aria-hidden="true">
              <div class="dialerCard" style="position:relative">
                <div style="display:flex;justify-content:space-between;align-items:center">
                  <div style="font-weight:700">Dial</div>
                  <div style="display:flex;gap:8px;align-items:center">
                    <button onclick="toggleDialerMenu(event)" title="Options" class="callAction" style="padding:6px 8px">⋮</button>
                    <button onclick="hideHomeDialer()" class="callAction reject" style="padding:6px 10px">Close</button>
                  </div>
                </div>
                <div id="dialerMenu" class="dialerMenu" style="right:12px;top:46px">
                  <button id="dialerAddContactBtn" onclick="showAddContactFromDialer()">Add as new contact</button>
                </div>
                <div id="homeDialDisplay" class="dialDisplay">&nbsp;</div>
                <div class="keypad" id="homeKeypad">
                  <button class="key" onclick="pressHomeDigit('1')">1</button>
                  <button class="key" onclick="pressHomeDigit('2')">2</button>
                  <button class="key" onclick="pressHomeDigit('3')">3</button>
                  <button class="key" onclick="pressHomeDigit('4')">4</button>
                  <button class="key" onclick="pressHomeDigit('5')">5</button>
                  <button class="key" onclick="pressHomeDigit('6')">6</button>
                  <button class="key" onclick="pressHomeDigit('7')">7</button>
                  <button class="key" onclick="pressHomeDigit('8')">8</button>
                  <button class="key" onclick="pressHomeDigit('9')">9</button>
                  <button class="key" onclick="pressHomeDigit('*')">*</button>
                  <button class="key" onclick="pressHomeDigit('0')">0</button>
                  <button class="key del" onclick="pressHomeBack()">⌫</button>
                </div>
                <div class="dialActions">
                  <button class="key action" style="flex:1;margin-right:6px" onclick="homeDialCall(true)">📹 Video</button>
                  <button class="key action" style="flex:1;margin-left:6px" onclick="homeDialCall(false)">🎧 Audio</button>
                </div>
                </div>
                <!-- add-contact small modal -->
                <div id="addContactModal" class="smallModal" role="dialog" aria-hidden="true">
                  <div style="font-weight:700">Add Contact</div>
                  <div class="muted small">Number</div>
                  <input id="addContactNumber" placeholder="Number" />
                  <div class="muted small" style="margin-top:8px">Label (optional)</div>
                  <input id="addContactLabelModal" placeholder="Label" />
                  <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end">
                    <button onclick="hideAddContactModal()" class="callAction reject">Cancel</button>
                    <button onclick="saveContactFromDialer()" class="callAction" style="background:linear-gradient(180deg,#06b6d4,#0891b2)">Save</button>
                  </div>
                </div>
            </div>
          </section>

          <section id="pageContacts" class="page" style="display:none;padding:6px">
            <label class="small muted">My Phonebook (only these contacts are visible)</label>
            <div style="display:flex;gap:8px;margin-top:8px">
              <input id="contactNumber" placeholder="12345" style="width:110px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit" />
              <input id="contactLabel" placeholder="Label (optional)" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit" />
              <button id="addContact">Add</button>
            </div>
            <div id="phonebook" style="margin-top:10px;max-height:240px;overflow:auto" class="small muted">No contacts yet</div>
            <div id="profileInfo" class="small muted" style="margin-top:10px">Not signed in</div>
          </section>

          <section id="pageDialer" class="page" style="display:none">
            <label>Dial</label>
            <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;margin-top:8px">
              <button id="openDialerBtn" class="callBtn video" title="Open dialer" style="flex:1;justify-content:center">📞 Open Dialer</button>
            </div>
            <div id="users" class="usersList"></div>
          </section>

          <section id="pageHistory" class="page" style="display:none">
            <div style="display:flex;align-items:center;justify-content:space-between">
              <label>Call History</label>
              <button id="clearHistory" style="background:#ef4444;color:white;border-radius:8px;padding:6px 10px;border:0">Clear History</button>
            </div>
            <div id="callLogs" style="margin-top:8px;max-height:320px;overflow:auto" class="small muted">No calls yet</div>
          </section>

          <section id="pageProfile" class="page" style="display:none">
            <h3>Profile</h3>
            <div class="small muted">You are signed in as <span id="profileDisplay"></span></div>
            <button id="signOut" style="margin-top:16px; background:#ef4444; color:white; border:0; padding:10px 16px; border-radius:8px">Logout</button>
          </section>
          
          <section id="pageMessenger" class="page" style="display:none;padding:6px">
            <div class="wa-messenger" style="display:flex;gap:12px;align-items:stretch;height:70vh">
              <!-- LEFT: contacts column -->
              <aside class="wa-contacts" style="width:320px;display:flex;flex-direction:column">
                <div class="wa-contacts-header" style="padding:10px 8px;display:flex;align-items:center;justify-content:space-between">
                  <div style="font-weight:700">Chats</div>
                  <button id="waNewChat" class="callAction" title="New chat" style="padding:6px 8px">＋</button>
                </div>
                <div style="padding:8px"><input id="waSearch" placeholder="Search or start new chat" style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit" /></div>
                <div id="messengerContacts" class="wa-contacts-list" style="flex:1;overflow:auto;padding:8px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);" aria-label="Contacts list">No contacts</div>
              </aside>

              <!-- RIGHT: chat area -->
              <main class="wa-chat" style="flex:1;display:flex;flex-direction:column">
                <div class="wa-chat-header" style="display:flex;align-items:center;justify-content:space-between;padding:8px 10px;border-bottom:1px solid rgba(255,255,255,0.02)">
                  <div style="display:flex;align-items:center;gap:12px">
                    <button id="waBackBtn" title="Back to chats" class="callAction" style="display:none;padding:6px 8px">◀</button>
                    <div id="chatAvatar" style="width:40px;height:40px;border-radius:50%;background:linear-gradient(135deg,#062b3a,#083047);display:flex;align-items:center;justify-content:center;font-weight:700;color:#c7eaf0">?</div>
                    <div>
                      <div id="chatWith" style="font-weight:700">No chat selected</div>
                      <div id="chatStatus" class="small muted">offline</div>
                    </div>
                  </div>
                  <div style="display:flex;align-items:center;gap:8px">
                    <button id="chatClearBtn" title="Clear chat" class="callAction" style="padding:6px 8px">🗑️</button>
                    <button id="chatFullBtn" title="Fullscreen chat" class="callAction" style="padding:6px 8px">⬜</button>
                  </div>
                </div>

                <div id="messagesList" class="wa-messages" style="flex:1;overflow:auto;padding:16px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);"> 
                  <div class="small muted">Select a contact to start chatting</div>
                </div>

                <div class="wa-input-bar" style="padding:10px;border-top:1px solid rgba(255,255,255,0.02);display:flex;gap:8px;align-items:center">
                  <button id="waAttach" title="Attach" class="callAction" style="padding:8px 10px">📎</button>
                  <input id="msgInput" placeholder="Type a message" style="flex:1;padding:10px;border-radius:20px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit" />
                  <button id="sendMsgBtn" class="callAction" style="background:linear-gradient(180deg,#06b6d4,#0891b2);padding:10px 14px;border-radius:20px">Send</button>
                </div>
              </main>
            </div>
          </section>

          <section id="pageSettings" class="page" style="display:none;padding:12px">
            <h3>Settings</h3>
            <div class="small muted">Placeholder settings page. Add options here.</div>
          </section>
        </div>
      </div>

      <div class="panel">
        <div class="videoStage" id="stage">
          <video id="remoteVideo" autoplay playsinline style="display:none"></video>
          <!-- idle overlay removed per user request; remote video remains hidden until connected -->
          <div class="localPreview" id="localPreview" style="display:none">
            <video id="localPreviewVideo" autoplay muted playsinline></video>
          </div>
            <!-- in-call overlay controls (mute / hangup) -->
            <div class="stageControls" id="stageControls" style="display:none">
              <button id="inCallMute" class="stageBtn mute" title="Mute">🎤</button>
              <button id="inCallHangup" class="stageBtn hangup" title="Hang up">📞</button>
            </div>
        </div>
        <div class="controls">
          <button id="endCall" style="background:#ef4444;display:none">Hang up</button>
          <button id="saveCallBtn" style="background:linear-gradient(180deg,#06b6d4,#028a9a);color:#002b2f;display:none;margin-left:6px;border-radius:8px;padding:8px 12px">Save Call</button>
          <div id="callStatus" class="small muted" style="align-self:center;display:none"></div>
        </div>
      </div>
    </div>

  </div>

  <!-- system nav bar (bottom) -->
  <div class="sysBar">
    <button id="navBack" title="Back" class="sysBack">◀</button>
    <button id="navHome" title="Home" class="sysHome">●</button>
  </div>
  </div>

  <!-- Incoming modal -->
  <div id="modal" class="modal" style="display:none">
    <div class="card">
      <h2 id="modalTitle">Incoming call</h2>
      <div id="modalFrom" class="muted small">Caller</div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center">
        <button id="acceptVideo" class="callAction acceptVid" title="Accept video">
          <!-- video camera icon -->
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17 10.5V7a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-3.5l4 4v-11l-4 4z" fill="white"/></svg>
          Video
        </button>
        <button id="acceptAudio" class="callAction acceptAud" title="Accept audio">
          <!-- phone icon -->
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 16.92v3a2 2 0 0 1-2.18 2A19.79 19.79 0 0 1 3 5.18 2 2 0 0 1 5 3h3a2 2 0 0 1 2 1.72c.12 1.05.38 2.07.78 3.03a2 2 0 0 1-.45 2.11L9.91 11.09a16 16 0 0 0 6 6l1.22-1.22a2 2 0 0 1 2.11-.45c.96.4 1.98.66 3.03.78A2 2 0 0 1 22 16.92z" fill="white"/></svg>
          Audio
        </button>
        <button id="reject" class="callAction reject" title="Reject">
          <!-- phone hangup icon -->
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21 16.5a16 16 0 0 1-9-9L21 16.5zM3 7.5a16 16 0 0 0 9 9L3 7.5z" fill="white"/></svg>
          Reject
        </button>
      </div>
    </div>
  </div>

  <!-- Contact call options modal -->
  <div id="contactCallModal" class="modal" style="display:none">
    <div class="card">
      <h2 id="contactCallTitle">Call</h2>
      <div id="contactCallNumber" class="muted small">Number</div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center">
        <button id="contactCallVideo" class="callAction acceptVid">Answer Video</button>
        <button id="contactCallAudio" class="callAction acceptAud">Answer Audio</button>
      </div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center">
        <button id="contactCallRemove" class="callAction reject" style="background:#ef4444;color:white">Remove</button>
        <button onclick="document.getElementById('contactCallModal').style.display='none'" class="callAction reject">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Dialing modal -->
  <div id="dialingModal" class="modal" style="display:none">
    <div class="card">
      <h2 id="dialingTitle">Dialing...</h2>
      <div class="muted small">Please wait while we connect you</div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center">
        <button id="cancelDial" class="callAction reject" title="Cancel">
          <!-- phone hangup icon -->
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21 16.5a16 16 0 0 1-9-9L21 16.5zM3 7.5a16 16 0 0 0 9 9L3 7.5z" fill="white"/></svg>
          Cancel
        </button>
      </div>
    </div>
  </div>

  <!-- Rejection notification modal -->
  <div id="rejectionModal" class="modal" style="display:none">
    <div class="card">
      <h2>Call Declined</h2>
      <div id="rejectionMessage" class="muted small">The call was declined</div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center">
        <button id="closeRejection" class="callAction reject" title="Close">
          OK
        </button>
      </div>
    </div>
  </div>

  <!-- Busy message modal -->
  <div id="busyModal" class="modal" style="display:none">
    <div class="card">
      <h2>Hold On!</h2>
      <div class="muted small">WAIT IM STILL FUCKING BUSY</div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center">
        <button id="closeBusy" class="callAction reject" title="Close">
          OK
        </button>
      </div>
    </div>
  </div>

  <!-- Settings modal -->
  <div id="settingsModal" class="modal" style="display:none">
    <div class="card">
      <h2>Settings</h2>
      <div style="margin-top:12px;display:flex;flex-direction:column;gap:8px;">
        <button onclick="installApp()" class="callAction" style="background:linear-gradient(180deg,#06b6d4,#0891b2)">Install App</button>
        <button onclick="clearAppData()" class="callAction" title="Clear cache & cookies" style="background:linear-gradient(180deg,#f97316,#dc2626)">Clear cache & cookies</button>
        <button onclick="settingsModal.style.display='none'" class="callAction reject">Close</button>
      </div>
    </div>
  </div>

<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js';
import { getDatabase, ref, set, onValue, off, push, update, child, get, runTransaction, onDisconnect } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js';

// Use the same Firebase config as your host page
const firebaseConfig = {
  apiKey: "AIzaSyD_5naeIoS-du5iwSlxhSCaxQnBVZ1Jn1Q",
  authDomain: "data-2-2b770.firebaseapp.com",
  databaseURL: "https://data-2-2b770-default-rtdb.firebaseio.com",
  projectId: "data-2-2b770",
  storageBucket: "data-2-2b770.firebasestorage.app",
  messagingSenderId: "560682274163",
  appId: "1:560682274163:web:1979df0d5ca13c2b784906",
  measurementId: "G-KBR7B4PMM8"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

const nameInput = document.getElementById('username');
const passwordInput = document.getElementById('password');
const createBtn = document.getElementById('registerBtn');
const signOutBtn = document.getElementById('signOut');
const loginBtn = document.getElementById('loginBtn');
const openDialerBtn = document.getElementById('openDialerBtn');
const contactNumberInput = document.getElementById('contactNumber');
const contactLabelInput = document.getElementById('contactLabel');
const addContactBtn = document.getElementById('addContact');
const phonebookDiv = document.getElementById('phonebook');
const profileInfo = document.getElementById('profileInfo');
const usersDiv = document.getElementById('users');
const modal = document.getElementById('modal');
const modalTitle = document.getElementById('modalTitle');
const modalFrom = document.getElementById('modalFrom');
const acceptVideoBtn = document.getElementById('acceptVideo');
const acceptAudioBtn = document.getElementById('acceptAudio');
const rejectBtn = document.getElementById('reject');
const remoteVideo = document.getElementById('remoteVideo');
const localPreview = document.getElementById('localPreview');
const localPreviewVideo = document.getElementById('localPreviewVideo');
const endCallBtn = document.getElementById('endCall');
const callStatus = document.getElementById('callStatus');

// Dialing modal elements
const dialingModal = document.getElementById('dialingModal');
const dialingTitle = document.getElementById('dialingTitle');
const cancelDialBtn = document.getElementById('cancelDial');

// Rejection modal elements
const rejectionModal = document.getElementById('rejectionModal');
const rejectionMessage = document.getElementById('rejectionMessage');
const closeRejectionBtn = document.getElementById('closeRejection');

// Busy modal elements
const busyModal = document.getElementById('busyModal');
const closeBusyBtn = document.getElementById('closeBusy');

// Auth and main app elements
const authContainer = document.getElementById('authContainer');
const mainApp = document.getElementById('mainApp');
const profileDisplay = document.getElementById('profileDisplay');

// --- simple page navigation (phone-like) ---
const navBackBtn = document.getElementById('navBack');
const navHomeBtn = document.getElementById('navHome');
const pageTitleEl = document.getElementById('pageTitle');
const pages = {
  home: document.getElementById('pageHome'),
  contacts: document.getElementById('pageContacts'),
  dial: document.getElementById('pageDialer'),
  history: document.getElementById('pageHistory'),
  profile: document.getElementById('pageProfile'),
  settings: document.getElementById('pageSettings'),
  messenger: document.getElementById('pageMessenger')
};
const tabHome = document.getElementById('tabHome');
const tabDial = document.getElementById('tabDial');
const tabHistory = document.getElementById('tabHistory');
const tabProfile = document.getElementById('tabProfile');
let inCall = false;

// Signal strength helper (0-4)
function setSignalStrength(level){
  try{
    level = Math.max(0, Math.min(4, Number(level)||0));
    const bars = document.querySelectorAll('#signalBars .bar');
    bars.forEach((b, i)=>{
      const idx = i+1;
      if(idx <= level) b.classList.add('active'); else b.classList.remove('active');
    });
    const el = document.getElementById('signalBars');
    if(el) el.setAttribute('data-level', String(level));
  }catch(e){console.error('setSignalStrength', e)}
}

// initialize to full strength
setTimeout(()=> setSignalStrength(4), 200);

// Live RTCPeerConnection signal monitor
let _signalMonitor = { intervalId: null, lastBytesReceived: 0, lastTimestamp: 0 };
function startSignalMonitor(pcInstance, intervalMs = 1500){
  try{
    if(!_signalMonitor) _signalMonitor = {};
    stopSignalMonitor();
    if(!pcInstance) return;
    _signalMonitor.intervalId = setInterval(async ()=>{
      try{
        const stats = await pcInstance.getStats();
        let packetsLost = 0, packetsTotal = 0, rtt = 0, jitter = 0;
        let found = false;
        stats.forEach(r => {
          // inbound-rtp usually contains packetsReceived/packetsLost and jitter
          if(r.type === 'inbound-rtp' && (r.kind==='video' || r.mediaType==='video' || r.trackId || r.mediaType==='audio')){
            found = true;
            packetsLost += Number(r.packetsLost || 0);
            packetsTotal += Number((r.packetsReceived || 0) + (r.packetsLost || 0));
            jitter = Math.max(jitter, Number(r.jitter || 0));
            if(r.roundTripTime) rtt = Math.max(rtt, Number(r.roundTripTime || 0));
          }
          // candidate-pair may contain currentRoundTripTime
          if(r.type === 'candidate-pair' && r.currentRoundTripTime){ rtt = Math.max(rtt, Number(r.currentRoundTripTime || 0)); }
        });

        // fallback: if nothing found, try outbound-rtp to estimate activity
        if(!found){
          stats.forEach(r=>{
            if(r.type === 'outbound-rtp' && (r.kind==='video' || r.mediaType==='video' || r.trackId)){
              found = true;
              // outbound reports don't include packetsLost client-side reliably
              packetsTotal += Number(r.packetsSent || 0);
            }
          });
        }

        let level = 4;
        if(found && packetsTotal>0){
          const lossRatio = packetsLost / Math.max(1, packetsTotal);
          // map loss ratio to a 0-4 scale (lower loss -> higher bars)
          if(lossRatio < 0.01) level = 4;
          else if(lossRatio < 0.03) level = 3;
          else if(lossRatio < 0.06) level = 2;
          else if(lossRatio < 0.12) level = 1;
          else level = 0;
          // degrade further on large rtt or jitter
          if(rtt && rtt > 0.3) level = Math.max(0, level - 1);
          if(jitter && jitter > 0.05) level = Math.max(0, level - 1);
        } else {
          // no reliable stats: if pc exists assume medium
          level = 3;
        }
        setSignalStrength(level);
      }catch(e){ console.warn('signal monitor error', e); }
    }, intervalMs);
  }catch(e){ console.warn('startSignalMonitor failed', e); }
}

function stopSignalMonitor(){
  try{
    if(_signalMonitor && _signalMonitor.intervalId){ clearInterval(_signalMonitor.intervalId); _signalMonitor.intervalId = null; }
  }catch(e){ console.warn('stopSignalMonitor', e); }
}

function enterCallMode() {
  inCall = true;
  // hide signal widget and stop monitoring during active call
  try{ const sig = document.querySelector('.signalWrapper'); if(sig){ sig.style.display = 'none'; sig.setAttribute('aria-hidden','true'); } }catch(e){}
  try{ stopSignalMonitor(); }catch(e){}
  const header = document.querySelector('header');
  if (header) header.style.display = 'none';
  const nav = document.querySelector('nav');
  if (nav) nav.style.display = 'none';
  // Hide all pages
  Object.values(pages).forEach(p => { if (p) p.style.display = 'none'; });
  // Hide panels
  const leftPanel = document.getElementById('leftPanel');
  if (leftPanel) leftPanel.style.display = 'none';
  const rightPanel = document.getElementById('rightPanel');
  if (rightPanel) rightPanel.style.display = 'none';
  // Remove app padding
  const app = document.querySelector('.app');
  if (app) app.style.padding = '0';
  // Prevent scrolling
  document.body.style.overflow = 'hidden';
  // Hide system nav (back/home) while in call
  const sysBar = document.querySelector('.sysBar');
  if (sysBar) sysBar.style.display = 'none';
  const navBackBtnEl = document.getElementById('navBack');
  const navHomeBtnEl = document.getElementById('navHome');
  if (navBackBtnEl) navBackBtnEl.style.display = 'none';
  if (navHomeBtnEl) navHomeBtnEl.style.display = 'none';
  // Show and fullscreen video stage (uses id 'stage')
  const videoStage = document.getElementById('stage') || document.querySelector('.videoStage');
  if (videoStage) {
    // move element to document.body to avoid parent clipping/scrolling
    if (videoStage.parentElement !== document.body) {
      document.body.appendChild(videoStage);
    }
    videoStage.style.display = 'flex';
    videoStage.style.position = 'fixed';
    videoStage.style.top = '0';
    videoStage.style.left = '0';
    videoStage.style.width = '100vw';
    videoStage.style.height = '100vh';
    videoStage.style.zIndex = '10000';
    // ensure videos fill the container
    videoStage.querySelectorAll('video').forEach(v => { v.style.width = '100%'; v.style.height = '100%'; v.style.objectFit = 'cover'; v.style.display = 'block'; });
    // ensure remote/local preview visible in call mode
    const remoteVideoEl = document.getElementById('remoteVideo');
    const localPreviewEl = document.getElementById('localPreview');
    if(remoteVideoEl) remoteVideoEl.style.display = 'block';
    if(localPreviewEl && localStream) localPreviewEl.style.display = 'block';
    // ensure top of viewport and focus
    try{ window.scrollTo(0,0); videoStage.scrollIntoView({behavior:'auto', block:'start'}); videoStage.focus && videoStage.focus(); }catch(e){}
  }
}

function exitCallMode() {
  inCall = false;
  const header = document.querySelector('header');
  if (header) header.style.display = 'block';
  const nav = document.querySelector('nav');
  if (nav) nav.style.display = 'block';
  // Show current page
  const currentPage = navStack.length > 0 ? navStack[navStack.length - 1] : 'home';
  navigateTo(currentPage, false);
  // Show panels
  const leftPanel = document.getElementById('leftPanel');
  if (leftPanel) leftPanel.style.display = 'block';
  const rightPanel = document.getElementById('rightPanel');
  if (rightPanel) rightPanel.style.display = 'block';
  // Restore app padding
  const app = document.querySelector('.app');
  if (app) app.style.padding = '';
  // Restore scrolling
  document.body.style.overflow = 'auto';
  // Show system nav again
  const sysBar = document.querySelector('.sysBar');
  if (sysBar) sysBar.style.display = 'flex';
  const navBackBtnEl = document.getElementById('navBack');
  const navHomeBtnEl = document.getElementById('navHome');
  if (navBackBtnEl) navBackBtnEl.style.display = '';
  if (navHomeBtnEl) navHomeBtnEl.style.display = '';
  // Reset video stage
  const videoStage = document.getElementById('stage') || document.querySelector('.videoStage');
  if (videoStage) {
    // move back into the panel container if possible
    const panel = document.querySelector('.panel');
    if (panel && videoStage.parentElement !== panel) {
      panel.appendChild(videoStage);
    }
    videoStage.style.display = 'none';
    videoStage.style.position = '';
    videoStage.style.top = '';
    videoStage.style.left = '';
    videoStage.style.width = '';
    videoStage.style.height = '';
    videoStage.style.zIndex = '';
    // reset video sizing
    videoStage.querySelectorAll('video').forEach(v => { v.style.width = ''; v.style.height = ''; v.style.objectFit = ''; });
    // restore signal widget visibility only if we're on the Dial page
    try{
      const current = currentPage || (navStack.length>0? navStack[navStack.length-1] : 'home');
      const sig = document.querySelector('.signalWrapper');
      if(sig){ if(String(current) === 'dial'){ sig.style.display = 'block'; sig.setAttribute('aria-hidden','false'); } else { sig.style.display = 'none'; sig.setAttribute('aria-hidden','true'); } }
    }catch(e){ }
  }
}
let navStack = [];

function navigateTo(pageId, push=true){
  // hide all pages
  Object.values(pages).forEach(p=>{ if(p) p.style.display='none'; });
  // show requested
  const p = pages[pageId.replace('page','').replace('page','')] || pages[pageId];
  // accept both 'home' or 'pageHome' ids
  const key = pageId.replace(/^page/,'').toLowerCase();
  const target = pages[key] || pages[pageId];
  if(target) target.style.display = 'block';
  // If navigating to the dial page, ensure dial UI is reset and any home dialer overlays are closed
  try{
    if(key === 'dial'){
      const di = document.getElementById('dialInput'); if(di) { di.value = ''; di.blur(); }
      const homeDial = document.getElementById('homeDialer'); if(homeDial){ homeDial.style.display = 'none'; homeDial.setAttribute('aria-hidden','true'); }
      const menu = document.getElementById('dialerMenu'); if(menu) menu.style.display = 'none';
      const addModal = document.getElementById('addContactModal'); if(addModal){ addModal.style.display = 'none'; addModal.setAttribute('aria-hidden','true'); }
    }
  }catch(e){ console.warn('navigateTo dial reset failed', e); }
  // title
  const titleMap = { home: 'Home', contacts: 'Contacts', dial: 'Call', history: 'Call History', profile: 'Profile', settings: 'Settings', messenger: 'Messenger' };
  pageTitleEl.textContent = titleMap[key] || 'Dialer';
  // manage nav stack
  if(push){ navStack.push(key); }
  // update bottom tabs active state
  [tabHome, tabDial, tabHistory, tabProfile].forEach(b=> b && b.classList && b.classList.remove('active'));
  if(key === 'home' && tabHome) tabHome.classList.add('active');
  if(key === 'dial' && tabDial) tabDial.classList.add('active');
  if(key === 'history' && tabHistory) tabHistory.classList.add('active');
  if(key === 'profile' && tabProfile) tabProfile.classList.add('active');
  // show signal only on Dial page
  try{
    const sig = document.querySelector('.signalWrapper');
    if(sig){
      if(key === 'dial'){
        sig.style.display = 'block'; sig.setAttribute('aria-hidden','false');
        try{ if(window.pc) startSignalMonitor(window.pc); }catch(e){}
      } else {
        sig.style.display = 'none'; sig.setAttribute('aria-hidden','true');
        try{ stopSignalMonitor(); }catch(e){}
      }
    }
  }catch(e){}
}

// back behavior
if(navBackBtn) navBackBtn.onclick = ()=>{
  if(navStack.length > 1){
    // drop current
    navStack.pop();
    const prev = navStack[navStack.length-1] || 'home';
    navigateTo(prev, false);
  } else navigateTo('home', false);
};
if(navHomeBtn) navHomeBtn.onclick = ()=>{ navStack = []; navigateTo('home', true); };

// Home dialer control functions
function showHomeDialer(){
  const d = document.getElementById('homeDialer');
  if(d){
    // ensure sub-elements are reset when opening
    d.style.display = 'flex';
    d.setAttribute('aria-hidden','false');
    const disp = document.getElementById('homeDialDisplay'); if(disp) disp.textContent = '';
    const menu = document.getElementById('dialerMenu'); if(menu) menu.style.display = 'none';
    const addModal = document.getElementById('addContactModal'); if(addModal) { addModal.style.display = 'none'; addModal.setAttribute('aria-hidden','true'); }
  }
}
function hideHomeDialer(){
  const d = document.getElementById('homeDialer');
  if(d){
    d.style.display = 'none'; d.setAttribute('aria-hidden','true');
    // also hide any open sub-UIs
    const menu = document.getElementById('dialerMenu'); if(menu) menu.style.display = 'none';
    const addModal = document.getElementById('addContactModal'); if(addModal) { addModal.style.display = 'none'; addModal.setAttribute('aria-hidden','true'); }
    const disp = document.getElementById('homeDialDisplay'); if(disp) disp.textContent = '';
  }
}
function pressHomeDigit(ch){
  const disp = document.getElementById('homeDialDisplay');
  if(!disp) return; const cur = (disp.textContent||'').replace(/\s/g,'');
  if(cur.length >= 20) return; // limit
  disp.textContent = (cur + ch).replace(/(.{3})/g,'$1 ').trim();
}
function pressHomeBack(){
  const disp = document.getElementById('homeDialDisplay'); if(!disp) return; const cur = (disp.textContent||'').replace(/\s/g,'');
  disp.textContent = cur.slice(0,-1).replace(/(.{3})/g,'$1 ').trim();
}
function homeDialCall(isVideo){
  const disp = document.getElementById('homeDialDisplay'); if(!disp) return; const num = (disp.textContent||'').replace(/\s/g,'');
  if(!/^[0-9*#]{3,}$/.test(num)) { alert('Enter a number to dial'); return; }
  hideHomeDialer();
  // If it's a proper 5-digit number, use existing helper; otherwise pass raw
  const n = num;
  initiateCallByNumber(n, !!isVideo);
}

// Expose to global scope for inline onclick handlers (module scripts are not global)
window.showHomeDialer = showHomeDialer;
window.hideHomeDialer = hideHomeDialer;
window.pressHomeDigit = pressHomeDigit;
window.pressHomeBack = pressHomeBack;
window.homeDialCall = homeDialCall;
// Dialer menu / add-contact handlers
function toggleDialerMenu(e){
  const menu = document.getElementById('dialerMenu');
  if(!menu) return;
  menu.style.display = (menu.style.display === 'block') ? 'none' : 'block';
  e && e.stopPropagation && e.stopPropagation();
}
function showAddContactFromDialer(){
  const disp = document.getElementById('homeDialDisplay'); if(!disp) return; const num = (disp.textContent||'').replace(/\s/g,'');
  if(!num) { alert('Enter a number first'); return; }
  // populate modal
  const modal = document.getElementById('addContactModal');
  if(!modal) return; document.getElementById('addContactNumber').value = num; document.getElementById('addContactLabelModal').value = '';
  modal.style.display = 'block'; modal.setAttribute('aria-hidden','false');
  // hide menu
  const menu = document.getElementById('dialerMenu'); if(menu) menu.style.display = 'none';
}
function hideAddContactModal(){ const m = document.getElementById('addContactModal'); if(m){ m.style.display='none'; m.setAttribute('aria-hidden','true'); } }
async function saveContactFromDialer(){
  const num = (document.getElementById('addContactNumber').value||'').trim();
  const label = (document.getElementById('addContactLabelModal').value||'').trim();
  if(!/^[0-9*#]{1,}$/.test(num)) return alert('Invalid number');
  try{
    const ok = await addContact(num, label);
    if(ok){ hideAddContactModal(); alert('Contact added'); }
    else alert('Failed to add contact');
  }catch(e){ console.error(e); alert('Error adding contact'); }
}
window.toggleDialerMenu = toggleDialerMenu; window.showAddContactFromDialer = showAddContactFromDialer; window.hideAddContactModal = hideAddContactModal; window.saveContactFromDialer = saveContactFromDialer;

// bottom tab handlers
if(tabHome) tabHome.onclick = ()=> navigateTo('home');
if(tabDial) tabDial.onclick = ()=> navigateTo('dial');
if(tabHistory) tabHistory.onclick = ()=> navigateTo('history');
if(tabProfile) tabProfile.onclick = ()=> navigateTo('profile');

// app-icon clicks on Home
document.querySelectorAll('.appIcon').forEach(btn=>{
  btn.onclick = ()=>{
    const t = btn.getAttribute('data-target');
    if(t === 'contacts') navigateTo('contacts');
    else if(t === 'dial') {
      // Always open the home dialer overlay when the Call icon is tapped
      showHomeDialer();
    }
    else if(t === 'history') navigateTo('history');
    else if(t === 'profile') navigateTo('profile');
    else if(t === 'settings') {
      settingsModal.style.display = 'flex';
    }
      else if(t === 'messenger') {
        // open the messenger page (simple global chat)
        navigateTo('messenger');
      }
  };
});

// default start page
navigateTo('home', false);

// in-call overlay controls
const inCallMuteBtn = document.getElementById('inCallMute');
const inCallHangupBtn = document.getElementById('inCallHangup');
const stageControls = document.getElementById('stageControls');
let audioMuted = false;

// call logging UI & state
const callLogsDiv = document.getElementById('callLogs');
const saveCallBtn = document.getElementById('saveCallBtn');
const clearHistoryBtn = document.getElementById('clearHistory');
let callStartTime = null;
let currentCallMeta = null; // { peer, media, direction }
let savedThisCall = false;
let lastCallSummary = null;

function showInCallControls(show){
  try{ if(stageControls) stageControls.style.display = show ? 'flex' : 'none'; }catch(e){}
}

// toggle mute/unmute local audio tracks
function toggleMute(){
  audioMuted = !audioMuted;
  if(localStream){
    for(const t of localStream.getAudioTracks()) t.enabled = !audioMuted;
  }
  if(inCallMuteBtn){ inCallMuteBtn.textContent = audioMuted ? '🔇' : '🎤'; inCallMuteBtn.title = audioMuted ? 'Unmute' : 'Mute'; }
}

if(inCallMuteBtn) inCallMuteBtn.onclick = ()=> toggleMute();
if(inCallHangupBtn) inCallHangupBtn.onclick = async ()=>{
  // reuse existing end call logic
  try{ if(currentSessionRef) await update(currentSessionRef, { status: 'ended', endedAt: Date.now() }); }catch(e){ console.error(e); }
  cleanupCall();
};

// Save current call (quick save). If there's an active call, capture its data; otherwise save last call.
async function quickSaveCall(){
  if(currentCallMeta && (callStartTime || !savedThisCall)){
    const startedAt = callStartTime || Date.now();
    const endedAt = Date.now();
    const duration = callStartTime ? (endedAt - callStartTime) : 0;
    const entry = { peer: currentCallMeta.peer, direction: currentCallMeta.direction, media: currentCallMeta.media, startedAt, endedAt, duration };
    await saveCallEntry(entry);
    savedThisCall = true;
    lastCallSummary = entry;
    if(callLogsDiv) renderLogsList(await fetchLogsOnce());
    alert('Call saved');
    return;
  }
  if(lastCallSummary){ await saveCallEntry(lastCallSummary); alert('Last call saved'); if(callLogsDiv) renderLogsList(await fetchLogsOnce()); return; }
  alert('No call to save');
}
if(saveCallBtn) saveCallBtn.onclick = ()=> quickSaveCall();

let myName = null;
let myRef = null; // ref to /users/<name>
let pc = null;
let localStream = null;
let currentSessionRef = null; // ref to ongoing session in /sessions

const pcConfig = {iceServers:[{urls:['stun:stun.l.google.com:19302']}]};

// clientId allows reclaiming your name across reloads (stored in localStorage)
let clientId = localStorage.getItem('dialerClientId') || null;
if(!clientId){ clientId = crypto.randomUUID ? crypto.randomUUID() : ('cid-' + Math.random().toString(36).slice(2)); localStorage.setItem('dialerClientId', clientId); }

// Prefill username if saved but do NOT auto-login (password required)
const savedName = localStorage.getItem('dialerName');
if(savedName){ nameInput.value = savedName; }

// Helper to toggle auth form visibility
function showAuthForm(visible){
  if(authContainer) authContainer.style.display = visible ? 'flex' : 'none';
}

function showMainApp(visible){
  if(mainApp) mainApp.style.display = visible ? 'block' : 'none';
}

// Idle control: hide remote video until connected. No idle overlay is shown per user preference.
function setIdle(show){
  // when idle (show=true) hide the whole video stage so user doesn't see a black box
  const stage = document.getElementById('stage');
  if(stage) stage.style.display = show ? 'none' : 'block';
  // also ensure remoteVideo is hidden when idle
  const rv = document.getElementById('remoteVideo');
  if(rv) rv.style.display = show ? 'none' : 'block';
}
// start idle state
setIdle(true);
// show auth form by default
showAuthForm(true);

// Open Dialer button (replaces inline dial input)
if(openDialerBtn) openDialerBtn.onclick = ()=>{ showHomeDialer(); };

// Register & login handlers (username + password)
createBtn.onclick = async ()=>{
  const rawName = (nameInput.value||'').trim();
  const pw = (passwordInput.value||'').trim();
  if(!rawName || !pw) return alert('Provide username and password');
  await registerUser(rawName, pw);
};

loginBtn.onclick = async ()=>{
  const rawName = (nameInput.value||'').trim();
  const pw = (passwordInput.value||'').trim();
  if(!rawName || !pw) return alert('Provide username and password');
  await loginWithPassword(rawName, pw);
};

// Helper: check media permissions
async function checkMediaPermissions(video = false) {
  try {
    const permissions = [];
    if (video) permissions.push(navigator.permissions.query({ name: 'camera' }));
    permissions.push(navigator.permissions.query({ name: 'microphone' }));
    const results = await Promise.all(permissions);
    for (const result of results) {
      if (result.state === 'denied') {
        alert('Camera/Microphone permission denied. Please allow access in browser settings and try again.');
        return false;
      }
    }
    return true;
  } catch (e) {
    // Fallback: try to get media briefly to check
    try {
      const stream = await navigator.mediaDevices.getUserMedia(video ? { video: true, audio: true } : { audio: true });
      stream.getTracks().forEach(track => track.stop());
      return true;
    } catch (err) {
      alert('Unable to access camera/microphone: ' + err.message);
      return false;
    }
  }
}

// Helper: ensure Firebase connection
function checkFirebaseConnection() {
  return navigator.onLine; // Basic check
}

// Helper: simple SHA-256 hash for password before storing (client-side)
async function hashPassword(pw){
  const enc = new TextEncoder();
  const data = enc.encode(pw);
  const hash = await crypto.subtle.digest('SHA-256', data);
  // convert to hex
  const bytes = new Uint8Array(hash);
  return Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join('');
}

// Register: create user with unique 5-digit number and store passwordHash
async function registerUser(rawName, password){
  const key = rawName.replace(/[.#$\[\]]/g,'_');
  const userRef = ref(db, 'users/' + key);
  try{
    const snap = await get(userRef);
    if(snap.exists()) return alert('Username already taken');

    // reserve number
    let reservedNumber = null;
    for(let tries=0; tries<10; ++tries){
      const n = Math.floor(10000 + Math.random()*90000).toString();
      const numRef = ref(db, 'numbers/' + n);
      try{
        const numTxn = await runTransaction(numRef, (cur)=>{ if(cur === null) return key; return; });
        if(numTxn.committed){ reservedNumber = n; break; }
      }catch(e){ console.warn('number txn failed', e); }
    }
    if(!reservedNumber) return alert('Failed to allocate number');

    const pwHash = await hashPassword(password);
    await set(userRef, { name: rawName, number: reservedNumber, passwordHash: pwHash, online: true, createdAt: Date.now(), lastSeen: Date.now(), clientId });
  myName = rawName; myRef = userRef; localStorage.setItem('dialerName', myName);
  profileInfo.textContent = `Signed in as: ${myName} #${reservedNumber}`;
  if(profileDisplay) profileDisplay.textContent = `${myName} #${reservedNumber}`;
  createBtn.style.display = 'none'; signOutBtn.style.display = 'inline-block';
  showAuthForm(false);
  showMainApp(true);
  await onDisconnect(myRef).update({ online: false, lastSeen: Date.now() });
  startListeningUsers(); startListeningSessions(); startListeningContacts();
  startListeningLogs();
  try{ startListeningPrivateRoot(); }catch(e){}
  if ('Notification' in window) { Notification.requestPermission(); }
    return true;
  }catch(e){ console.error('register failed', e); alert('Register failed: ' + e); }
}

// Login with username + password
async function loginWithPassword(rawName, password){
  const key = rawName.replace(/[.#$\[\]]/g,'_');
  const userRef = ref(db, 'users/' + key);
  try{
    const snap = await get(userRef);
    if(!snap.exists()) return alert('No user with that name');
    const u = snap.val();
    const pwHash = await hashPassword(password);
    if(u.passwordHash !== pwHash) return alert('Invalid password');
  myName = rawName; myRef = userRef; localStorage.setItem('dialerName', myName);
  profileInfo.textContent = `Signed in as: ${myName} #${u.number}`;
  if(profileDisplay) profileDisplay.textContent = `${myName} #${u.number}`;
  createBtn.style.display = 'none'; signOutBtn.style.display = 'inline-block';
  showAuthForm(false);
  showMainApp(true);
  await onDisconnect(myRef).update({ online: false, lastSeen: Date.now() });
  await update(myRef, { online: true, lastSeen: Date.now() });
  startListeningUsers(); startListeningSessions(); startListeningContacts();
  startListeningLogs();
  if ('Notification' in window) { Notification.requestPermission(); }
    return true;
  }catch(e){ console.error(e); alert('Login failed: ' + e); }
}

// --- Phonebook: per-user contacts (stored at /contacts/<userKey>) ---
let contactsMap = {}; // number -> {number,label}
// derive the sanitized DB key for the current user
function getMyKey(){
  try{
    if(myName) return myName.replace(/[.#$\[\]]/g,'_');
    // fallback: attempt to parse from ref if available
    if(myRef && typeof myRef.toString === 'function'){
      const s = String(myRef.toString());
      // firebase ref string may look like '/users/<key>'
      const parts = s.split('/');
      return parts[parts.length-1] || null;
    }
  }catch(e){ /* ignore */ }
  return null;
}
function startListeningContacts(){
  const key = getMyKey();
  if(!key) return;
  const contactsRef = ref(db, 'contacts/' + key);
  onValue(contactsRef, (snap)=>{
    const val = snap.val() || {};
    contactsMap = val;
    renderPhonebook();
    // re-render users filtered by phonebook
    get(ref(db, 'users')).then(snapUsers=>{ renderUsers(Object.values(snapUsers.val() || {})); }).catch(()=>{});
  });
}

function renderPhonebook(){
  phonebookDiv.innerHTML = '';
  const keys = Object.keys(contactsMap || {});
  if(keys.length === 0){ phonebookDiv.textContent = 'No contacts yet'; return; }
  for(const num of keys){
    const info = contactsMap[num];
    const row = document.createElement('div');
    row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center'; row.style.padding='6px 0';
    const left = document.createElement('div'); left.innerHTML = `<strong>${info.label || info.number}</strong><div class="small muted">${info.number}</div>`;
    const right = document.createElement('div');
    right.style.display = 'flex'; right.style.gap = '8px'; right.style.alignItems = 'center';
    // call button
    const callBtn = document.createElement('button'); callBtn.textContent='📞'; callBtn.title='Call'; callBtn.className='callBtn'; callBtn.style.padding='8px 10px'; callBtn.onclick = ()=> showContactCallOptions(info.number, info.label || '');
  right.appendChild(callBtn);
    row.appendChild(left); row.appendChild(right); phonebookDiv.appendChild(row);
  }
}

// --- Messenger: simple global chat room ---
// --- Messenger: private one-to-one chats ---
let usersCache = {};
let selectedChatPeer = null;
let selectedChatId = null;
let privateMsgsRef = null;
let privateMsgsCallback = null;
let unreadCounts = {}; // chatId -> number

function startListeningUsers(){
  const usersRef = ref(db, 'users');
  onValue(usersRef, (snap)=>{
    const val = snap.val() || {};
    usersCache = val;
    try{ renderUsers(Object.values(val)); }catch(e){}
    try{ buildMessengerContacts(); }catch(e){}
    try{ restoreUnreadCounts(); updateAllContactBadges(); updateGlobalBadge(); }catch(e){}
  });
}

function buildMessengerContacts(){
  const cont = document.getElementById('messengerContacts');
  if(!cont) return;
  cont.innerHTML = '';
  const arr = Object.values(usersCache || {}).filter(u=>u && u.name).sort((a,b)=> (a.name||'').localeCompare(b.name||''));
  for(const u of arr){
    if(u.name === myName) continue;
    const btn = document.createElement('button');
    btn.className = 'messengerContactBtn';
    btn.dataset.name = u.name;
    // show only username (no number) with avatar and small meta (WhatsApp-like)
    const avatar = document.createElement('div'); avatar.className = 'avatar-small'; avatar.textContent = (u.name||'?').charAt(0).toUpperCase();
    const meta = document.createElement('div'); meta.className = 'contact-meta';
    const nm = document.createElement('div'); nm.className = 'contact-name'; nm.textContent = u.name;
    const sub = document.createElement('div'); sub.className = 'contact-sub'; sub.textContent = u.online ? 'Online' : 'Offline';
    meta.appendChild(nm); meta.appendChild(sub);
    btn.appendChild(avatar); btn.appendChild(meta);
    // unread badge placeholder
    const badge = document.createElement('span'); badge.className = 'contact-badge'; badge.style.display = 'none'; badge.textContent = '0'; badge.style.marginLeft = 'auto'; btn.appendChild(badge);
    btn.onclick = ()=> openChatWith(u.name);
    cont.appendChild(btn);
  }
  if(cont.children.length === 0) cont.innerHTML = '<div class="small muted">No contacts</div>';
}

function getChatId(peerName){
  const a = (getMyKey() || '').toString();
  const b = (peerName||'').replace(/[.#$\[\]]/g,'_');
  return [a,b].sort().join('_');
}

function openChatWith(peerName){
  if(!peerName) return;
  selectedChatPeer = peerName;
  selectedChatId = getChatId(peerName);
  document.getElementById('chatWith').textContent = peerName;
  // unsubscribe previous
  try{ if(privateMsgsRef && privateMsgsCallback) off(privateMsgsRef, 'value', privateMsgsCallback); }catch(e){}
  privateMsgsRef = ref(db, 'messages/private/' + selectedChatId);
  privateMsgsCallback = (snap)=>{ renderPrivateMessages(snap.val() || {}); };
  onValue(privateMsgsRef, privateMsgsCallback);
  // highlight selected contact button
  try{
    document.querySelectorAll('#messengerContacts button.messengerContactBtn').forEach(b=> b.classList.remove('selected'));
    const sel = document.querySelector(`#messengerContacts button.messengerContactBtn[data-name="${peerName}"]`);
    if(sel) sel.classList.add('selected');
  }catch(e){}
  
  // set avatar initial and status
  try{ const av = document.getElementById('chatAvatar'); if(av) av.textContent = (peerName||'?').charAt(0).toUpperCase(); }catch(e){}
  try{ const st = document.getElementById('chatStatus'); if(st){ const u = usersCache && usersCache[peerName.replace(/[.#$\[\]]/g,'_')]; st.textContent = u && u.online ? 'Online' : 'Offline'; } }catch(e){}
  // on small screens hide contacts column when chat opened (WhatsApp mobile behaviour)
  try{ if(window.innerWidth <= 640){ document.querySelector('.wa-contacts').style.display = 'none'; const back = document.getElementById('waBackBtn'); if(back) back.style.display = 'inline-block'; } }catch(e){}
  // clear unread count for this chat
  try{ if(selectedChatId){ unreadCounts[selectedChatId] = 0; updateContactBadge(selectedChatId); updateGlobalBadge(); localStorage.setItem('unreadCounts_'+(getMyKey()||''), JSON.stringify(unreadCounts)); } }catch(e){}
}

function renderPrivateMessages(messages){
  const list = document.getElementById('messagesList');
  if(!list) return;
  list.innerHTML = '';
  const keys = Object.keys(messages || {});
  if(keys.length === 0){ list.innerHTML = '<div class="small muted">No messages yet</div>'; return; }
  const items = keys.map(k=> Object.assign({ _id: k }, messages[k])).sort((a,b)=> (a.ts||0) - (b.ts||0));
  // apply clearedAt filter (local clear chat) if set
  const clearedAt = getClearedTs(selectedChatId);
  for(const it of items){
    if(clearedAt && it.ts && it.ts <= clearedAt) continue;
  const row = document.createElement('div');
  row.className = 'msg-row';
  row.style.marginBottom='8px';
    const mine = (it.from === myName);
    if(mine){ row.style.justifyContent='flex-end'; }
  const bubble = document.createElement('div');
  bubble.className = 'msg-bubble ' + (mine ? 'mine' : 'their');
  bubble.textContent = it.text || '';
  const meta = document.createElement('div'); meta.className='msg-meta'; meta.textContent = it.ts ? new Date(it.ts).toLocaleTimeString() : '';
  const wrapper = document.createElement('div'); wrapper.style.display='flex'; wrapper.style.flexDirection='column'; wrapper.appendChild(bubble); wrapper.appendChild(meta);
    row.appendChild(wrapper);
    list.appendChild(row);
  }
  try{ list.scrollTop = list.scrollHeight; }catch(e){}
}

function getClearedTs(chatId){
  try{
    if(!chatId) return null;
    const key = 'cleared_' + (getMyKey() || '') + '_' + chatId;
    const val = localStorage.getItem(key);
    return val ? Number(val) : null;
  }catch(e){ return null; }
}

async function sendPrivateMessage(){
  const inp = document.getElementById('msgInput');
  if(!inp) return;
  const txt = (inp.value||'').trim();
  if(!txt) return;
  if(!myName) return alert('Sign in to send messages');
  if(!selectedChatPeer || !selectedChatId) return alert('Select a contact to chat with');
  try{
    const payload = { from: myName, to: selectedChatPeer, text: txt, ts: Date.now() };
    const p = push(ref(db, 'messages/private/' + selectedChatId));
    await set(p, payload);
    inp.value = '';
    // after sending in current chat, reset unread and update badges
    try{ if(selectedChatId){ unreadCounts[selectedChatId] = 0; updateContactBadge(selectedChatId); updateGlobalBadge(); localStorage.setItem('unreadCounts_'+(getMyKey()||''), JSON.stringify(unreadCounts)); } }catch(e){}
  }catch(e){ console.error('sendPrivateMessage failed', e); alert('Message failed to send'); }
}

// wire send button and Enter key for private chat
document.addEventListener('click', (e)=>{
  if(e.target && e.target.id === 'sendMsgBtn'){ sendPrivateMessage(); }
  // back button on mobile
  if(e.target && e.target.id === 'waBackBtn'){ try{ document.querySelector('.wa-contacts').style.display = ''; e.target.style.display='none'; }catch(e){} }
});
document.addEventListener('keydown', (e)=>{
  const active = document.activeElement;
  if(active && active.id === 'msgInput' && e.key === 'Enter'){
    e.preventDefault(); sendPrivateMessage();
  }
});

// disable send when input empty and keep send visible when typing
const waInput = document.getElementById('msgInput');
const waSend = document.getElementById('sendMsgBtn');
if(waInput && waSend){
  waSend.disabled = true;
  waInput.addEventListener('input', ()=>{ waSend.disabled = !(waInput.value||'').trim(); });
}

// Chat window controls: fullscreen
let chatFullscreen = false;
let messengerOriginalParent = null;
let messengerOriginalNextSibling = null;
function toggleChatFullscreen(){
  const pm = document.getElementById('pageMessenger'); if(!pm) return;
  chatFullscreen = !chatFullscreen;
  if(chatFullscreen){
    // store original position
    messengerOriginalParent = pm.parentElement;
    messengerOriginalNextSibling = pm.nextSibling;
    // move to body so it can overlay everything
    document.body.appendChild(pm);
    pm.classList.add('pm-fullscreen');
    // hide contacts column inside fullscreen
    try{ const cont = document.getElementById('messengerContacts'); if(cont) cont.style.display = 'none'; }catch(e){}
    try{ const sys = document.querySelector('.sysBar'); if(sys) sys.style.display='none'; }catch(e){}
    try{ document.body.style.overflow = 'hidden'; }catch(e){}
  } else {
    // restore
    pm.classList.remove('pm-fullscreen');
    try{ const cont = document.getElementById('messengerContacts'); if(cont) cont.style.display = ''; }catch(e){}
    try{ const sys = document.querySelector('.sysBar'); if(sys) sys.style.display='flex'; }catch(e){}
    try{ document.body.style.overflow = ''; }catch(e){}
    // move back to original parent position
    try{
      if(messengerOriginalParent){
        if(messengerOriginalNextSibling) messengerOriginalParent.insertBefore(pm, messengerOriginalNextSibling);
        else messengerOriginalParent.appendChild(pm);
      }
    }catch(e){ console.warn('restore messenger position failed', e); }
  }
}
// wire header buttons (elements exist in DOM when script runs)
try{
  const clearB = document.getElementById('chatClearBtn'); if(clearB) clearB.onclick = async ()=>{
    if(!selectedChatId) return alert('No chat selected');
    if(!confirm('Clear messages in this chat from your view? This will hide existing messages for you locally.')) return;
    const key = 'cleared_' + (getMyKey() || '') + '_' + selectedChatId;
    localStorage.setItem(key, String(Date.now()));
    // reset unread and UI
    unreadCounts[selectedChatId] = 0; updateContactBadge(selectedChatId); updateGlobalBadge(); localStorage.setItem('unreadCounts_'+(getMyKey()||''), JSON.stringify(unreadCounts));
    // re-render chat
    try{ renderPrivateMessages((await get(ref(db, 'messages/private/' + selectedChatId))).val() || {}); }catch(e){}
  };
  const fullB = document.getElementById('chatFullBtn'); if(fullB) fullB.onclick = toggleChatFullscreen;
}catch(e){}


// Contact call helper
let contactCallTarget = null;
function showContactCallOptions(number, label){
  contactCallTarget = number;
  const m = document.getElementById('contactCallModal');
  if(!m) return;
  const name = label || number;
  document.getElementById('contactCallTitle').textContent = `Call ${name}`;
  document.getElementById('contactCallNumber').textContent = number;
  const vidBtn = document.getElementById('contactCallVideo');
  const audBtn = document.getElementById('contactCallAudio');
  if(vidBtn){ vidBtn.textContent = `Video call "${name}"`; vidBtn.onclick = ()=>{ m.style.display='none'; initiateCallByNumber(number, true); }; }
  if(audBtn){ audBtn.textContent = `Call "${name}"`; audBtn.onclick = ()=>{ m.style.display='none'; initiateCallByNumber(number, false); }; }
  const remBtn = document.getElementById('contactCallRemove');
  if(remBtn){ remBtn.textContent = `Remove "${name}"`; remBtn.onclick = ()=>{ m.style.display='none'; removeContact(number); } }
  m.style.display = 'flex';
}

async function addContact(number, label){
  if(!myName) return alert('Sign in first');
  if(!/^[0-9]{5}$/.test(number)) return alert('Enter a valid 5-digit number');
  const key = getMyKey();
  if(!key) return alert('Sign in first');
  const cRef = ref(db, 'contacts/' + key + '/' + number);
  try{
    await set(cRef, { number, label: label || '' });
    return true;
  }catch(e){ console.error('addContact failed', e); alert('Failed to add contact'); }
}

async function removeContact(number){
  if(!myName) return; const key = getMyKey(); if(!key) return;
  try{ await set(ref(db, 'contacts/' + key + '/' + number), null); }catch(e){ console.error(e); }
}

addContactBtn && (addContactBtn.onclick = ()=>{ const num = (contactNumberInput.value||'').trim(); const lbl = (contactLabelInput.value||'').trim(); addContact(num, lbl); contactNumberInput.value=''; contactLabelInput.value=''; });

signOutBtn.onclick = async ()=>{
  if(!myRef) return;
  try{
    await update(myRef, { online: false, lastSeen: Date.now() });
    profileInfo.textContent = 'Signed out';
    createBtn.style.display = 'inline-block';
    signOutBtn.style.display = 'none';
    localStorage.removeItem('dialerName');
    // keep clientId so we can reclaim later
    myName = null; myRef = null;
    usersDiv.innerHTML = '';
    contactsMap = {};
    phonebookDiv.innerHTML = 'No contacts yet';
    showAuthForm(true);
    showMainApp(false);
    // return to idle state
    setIdle(true);
  }catch(e){ console.error(e); }
};

// --- Users list ---

function renderUsers(users){
  usersDiv.innerHTML = '';
  users.sort((a,b)=> (a.name||'').localeCompare(b.name||''));
  for(const u of users){
    // skip if no name
    if(!u || !u.name) continue;
    // if signed in, only show contacts that are in our phonebook (unless it's ourselves)
    if(myName && myName !== u.name){
      if(!contactsMap || !Object.prototype.hasOwnProperty.call(contactsMap, String(u.number))){
        continue; // not in phonebook
      }
    }
    const row = document.createElement('div');
    row.className = 'userRow';
    const left = document.createElement('div'); left.className='userMeta';
    const dot = document.createElement('div'); dot.className='dot ' + (u.online? 'online':'offline');
    const nm = document.createElement('div'); nm.innerHTML = `<div style="font-weight:600">${u.name} <span style="font-weight:600;color:var(--accent);font-size:0.9rem">#${u.number || '----'}</span></div><div class="small muted">${u.online? 'Online': 'Offline'}</div>`;
    left.appendChild(dot); left.appendChild(nm);

    const right = document.createElement('div');
    if(myName && myName !== u.name && u.online){
      const btnCallVid = document.createElement('button'); btnCallVid.textContent='📹'; btnCallVid.className='callBtn video';
      const btnCallAud = document.createElement('button'); btnCallAud.textContent='🎧'; btnCallAud.className='callBtn audio';
      btnCallVid.title = 'Call (Video)'; btnCallAud.title = 'Call (Audio)';
      btnCallVid.onclick = ()=> initiateCall(u.name, true);
      btnCallAud.onclick = ()=> initiateCall(u.name, false);
      right.appendChild(btnCallVid); right.appendChild(btnCallAud);
    } else {
      right.innerHTML = '<div class="small muted">' + (u.name === myName ? 'You' : '') + '</div>';
    }

    row.appendChild(left); row.appendChild(right);
    usersDiv.appendChild(row);
  }
}

function updateContactBadgeForName(name){
  try{
    const key = getChatId(name);
    updateContactBadge(key);
  }catch(e){}
}

function updateContactBadge(chatId){
  try{
    if(!chatId) return;
    const cont = document.getElementById('messengerContacts');
    if(!cont) return;
    // find button by data-name matching either peer name
    const btn = Array.from(cont.querySelectorAll('button.messengerContactBtn')).find(b=> getChatId(b.dataset.name) === chatId);
    if(!btn) return;
    const badge = btn.querySelector('.contact-badge');
    const n = unreadCounts[chatId] || 0;
    if(badge){ if(n>0){ badge.style.display='inline-flex'; badge.textContent = n>99 ? '99+' : String(n); } else { badge.style.display='none'; } }
  }catch(e){ console.warn('updateContactBadge failed', e); }
}

function updateAllContactBadges(){
  try{ Object.keys(unreadCounts||{}).forEach(k=> updateContactBadge(k)); }catch(e){}
}

function updateGlobalBadge(){
  try{
    const total = Object.values(unreadCounts||{}).reduce((s,v)=> s + (Number(v)||0), 0);
    const appBtn = Array.from(document.querySelectorAll('.appIcon')).find(b=> b.dataset && b.dataset.target === 'messenger');
    if(!appBtn) return;
    let gb = appBtn.querySelector('.messenger-global-badge');
    if(total > 0){ if(!gb){ gb = document.createElement('span'); gb.className='messenger-global-badge'; appBtn.style.position='relative'; appBtn.appendChild(gb); } gb.textContent = total>99 ? '99+' : String(total); }
    else { if(gb) gb.remove(); }
  }catch(e){ console.warn('updateGlobalBadge failed', e); }
}

function restoreUnreadCounts(){
  try{
    const key = 'unreadCounts_'+(getMyKey()||'');
    const raw = localStorage.getItem(key);
    if(raw) unreadCounts = JSON.parse(raw) || {};
    else unreadCounts = {};
  }catch(e){ unreadCounts = {}; }
}

// seen timestamps per chat to compute unread counts
let seenTimestamps = {};
function restoreSeenTimestamps(){
  try{ const k = 'seen_'+(getMyKey()||''); const raw = localStorage.getItem(k); if(raw) seenTimestamps = JSON.parse(raw) || {}; else seenTimestamps = {}; }catch(e){ seenTimestamps = {}; }
}
function saveSeenTimestamps(){ try{ localStorage.setItem('seen_'+(getMyKey()||''), JSON.stringify(seenTimestamps || {})); }catch(e){} }

// Listen to root of private messages to compute per-chat unread counts
function startListeningPrivateRoot(){
  try{
    restoreSeenTimestamps(); restoreUnreadCounts();
    const rootRef = ref(db, 'messages/private');
    onValue(rootRef, (snap)=>{
      const val = snap.val() || {};
      // for each chatId compute last ts and unread count
      Object.keys(val).forEach(chatId => {
        try{
          const msgs = val[chatId] || {};
          // compute max ts and count unread
          let maxTs = 0; let unread = 0; let arr = Object.values(msgs || {});
          arr.forEach(m => { if(m && m.ts){ if(m.ts > maxTs) maxTs = m.ts; } });
          const clearedAt = getClearedTs(chatId);
          const seen = seenTimestamps[chatId] || 0;
          arr.forEach(m => { if(m && m.ts){ const effectiveSeen = Math.max(seen || 0, clearedAt || 0); if(m.ts > effectiveSeen){ unread += 1; } } });
          // if chat is currently open, mark seen and unread=0
          if(selectedChatId === chatId){ seenTimestamps[chatId] = maxTs; unread = 0; }
          unreadCounts[chatId] = unread;
        }catch(e){ console.warn('privateRoot process failed for', chatId, e); }
      });
  // update UI
  updateAllContactBadges(); updateGlobalBadge();
  try{ if(window.updateNotifBadge) window.updateNotifBadge(); }catch(e){}
  saveSeenTimestamps(); localStorage.setItem('unreadCounts_'+(getMyKey()||''), JSON.stringify(unreadCounts));
    });
  }catch(e){ console.warn('startListeningPrivateRoot failed', e); }
}


// --- Sessions (signaling) ---
function startListeningSessions(){
  const sessionsRef = ref(db, 'sessions');
  onValue(sessionsRef, (snap)=>{
    const sessions = snap.val() || {};
    for(const key of Object.keys(sessions)){
      const s = sessions[key];
      if(!s || s.status !== 'pending') continue;
      // only show incoming calls targeted to me
      if(s.to && myName && s.to === myName){
        showIncomingCall(key, s);
      }
    }
  });
}

let incomingKey = null;
let incomingSession = null;

function startRinging() {
  const ringAudio = document.getElementById('ringAudio');
  if (ringAudio) {
    ringAudio.currentTime = 0;
    ringAudio.play().catch(e => console.warn('Could not play ringtone', e));
  }
  // Also send to SW for background
  if (swRegistration && swRegistration.active) {
    swRegistration.active.postMessage('startRing');
  }
}

function stopRinging() {
  const ringAudio = document.getElementById('ringAudio');
  if (ringAudio) {
    ringAudio.pause();
    ringAudio.currentTime = 0;
  }
  // Send to SW
  if (swRegistration && swRegistration.active) {
    swRegistration.active.postMessage('stopRing');
  }
}

function showIncomingCall(key, session){
  if(incomingKey) return; // already showing
  incomingKey = key; incomingSession = session;
  modal.style.display = 'flex';
  modalTitle.textContent = `${session.media === 'video' ? 'Video' : 'Audio'} call`;
  modalFrom.textContent = `From: ${session.from || 'Unknown'}`;
  if ('Notification' in window && Notification.permission === 'granted') {
    showNotification('Incoming ' + session.media + ' call from ' + session.from, {
      actions: [
        { action: 'answer', title: 'Answer' },
        { action: 'reject', title: 'Reject' }
      ],
      data: { callKey: key }
    });
  }
  if (navigator.vibrate) {
    navigator.vibrate(200);
  }
  startRinging();
  // Check URL params for auto action
  const urlParams = new URLSearchParams(window.location.search);
  const action = urlParams.get('action');
  const callKeyParam = urlParams.get('callKey');
  if (action && callKeyParam === key) {
    if (action === 'answer') {
      // Auto answer
      acceptIncoming(session.media === 'video');
    } else if (action === 'reject') {
      // Auto reject
      rejectBtn.click();
    }
    // Clean URL
    window.history.replaceState(null, null, window.location.pathname);
  }
  // Show only the relevant accept button based on call type
  if (session.media === 'video') {
    acceptVideoBtn.style.display = 'inline-block';
    acceptAudioBtn.style.display = 'none';
  } else {
    acceptVideoBtn.style.display = 'none';
    acceptAudioBtn.style.display = 'inline-block';
  }
}

rejectBtn.onclick = async ()=>{
  if(!incomingKey) return;
  const sref = ref(db, 'sessions/' + incomingKey);
  await update(sref, { status: 'rejected' });
  closeModal();
};

cancelDialBtn.onclick = async ()=>{
  if(!currentSessionRef) return;
  try{ await update(currentSessionRef, { status: 'ended', endedAt: Date.now() }); }catch(e){ console.error(e); }
  cleanupCall();
  closeDialingModal();
};

closeRejectionBtn.onclick = ()=>{
  rejectionModal.style.display = 'none';
};

closeBusyBtn.onclick = ()=>{
  busyModal.style.display = 'none';
};

acceptVideoBtn.onclick = ()=> acceptIncoming(true);
acceptAudioBtn.onclick = ()=> acceptIncoming(false);

async function acceptIncoming(isVideo){
  if(!await checkMediaPermissions(isVideo)){ closeModal(); return; }
  try{
    // record call meta for incoming call
    currentCallMeta = { peer: incomingSession.from, media: isVideo ? 'video' : 'audio', direction: 'incoming' };
    // get local media according to selection
    localStream = await navigator.mediaDevices.getUserMedia(isVideo ? {video:true,audio:true} : {audio:true});
    showLocalPreview(localStream);

    // create peer connection and set remote offer
    makePeerConnection();
    for(const t of localStream.getTracks()) pc.addTrack(t, localStream);

    const offer = (typeof incomingSession.offer === 'string') ? JSON.parse(incomingSession.offer) : incomingSession.offer;
    await pc.setRemoteDescription(offer);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    // write answer back to session with retry
    const sref = ref(db, 'sessions/' + incomingKey);
    let retries = 3;
    while (retries > 0) {
      try {
        await update(sref, { answer: JSON.stringify(pc.localDescription), status: 'answered', answeredAt: Date.now() });
        break;
      } catch (e) {
        retries--;
        if (retries === 0) throw e;
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    currentSessionRef = sref;
    callStatus.textContent = `In call with ${incomingSession.from}`;
    endCallBtn.style.display = 'inline-block';
    showInCallControls(true);
    // mark call started now (this is a reasonable proxy for connection start)
    callStartTime = Date.now(); savedThisCall = false;
    if(saveCallBtn) saveCallBtn.style.display = 'inline-block';
  }catch(e){ console.error('accept failed', e); alert('Failed to accept call: ' + e.message + '. Please try again.'); cleanupCall(); }
  closeModal();
  enterCallMode();
}

function closeModal(){ 
  incomingKey = null; 
  incomingSession = null; 
  modal.style.display = 'none';
  stopRinging();
  // Reset button visibility
  acceptVideoBtn.style.display = 'inline-block';
  acceptAudioBtn.style.display = 'inline-block';
}

function closeDialingModal(){ dialingModal.style.display = 'none'; }

// --- Initiate call ---
async function initiateCall(targetName, isVideo){
  if(!myName){ alert('Please sign in first to make calls.'); return; }
  if(currentSessionRef){ alert('You are already in a call. Please end it first.'); return; }
  if(!checkFirebaseConnection()){ alert('No internet connection. Please check your network.'); return; }
  if(!await checkMediaPermissions(isVideo)){ return; }
  try{
    // get local media early so we can add tracks
    localStream = await navigator.mediaDevices.getUserMedia(isVideo ? {video:true,audio:true} : {audio:true});
    showLocalPreview(localStream);

    makePeerConnection();
    for(const t of localStream.getTracks()) pc.addTrack(t, localStream);

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    await waitForIceGatheringComplete(pc);
    // push session to DB with retry
    let newSessionRef;
    let retries = 3;
    while (retries > 0) {
      try {
        const sessionsRef = ref(db, 'sessions');
        newSessionRef = push(sessionsRef);
        await set(newSessionRef, { from: myName, to: targetName, media: isVideo? 'video':'audio', offer: JSON.stringify(pc.localDescription), status: 'pending', createdAt: Date.now() });
        break;
      } catch (e) {
        retries--;
        if (retries === 0) throw e;
        await new Promise(resolve => setTimeout(resolve, 1000)); // wait 1s before retry
      }
    }
    currentSessionRef = newSessionRef;
    // show dialing modal
    dialingTitle.textContent = `Dialing ${targetName}`;
    dialingModal.style.display = 'flex';
    if ('Notification' in window && Notification.permission === 'granted') {
      showNotification('Calling ' + targetName);
    }
    // store call meta for outgoing call
  currentCallMeta = { peer: targetName, media: isVideo ? 'video' : 'audio', direction: 'outgoing' };

    // set timeout for no answer
    const timeoutId = setTimeout(async () => {
      if(!pc.remoteDescription){
        alert('Call timed out - no answer. Please try again.');
        try{ await update(currentSessionRef, { status: 'ended', endedAt: Date.now() }); }catch(e){}
        cleanupCall();
        closeDialingModal();
      }
    }, 30000);

    // listen for answer on this session
    onValue(newSessionRef, async (snap)=>{
      const val = snap.val();
      if(!val) return;
      if(val.answer && pc && !pc.remoteDescription){
        closeDialingModal();
        try{
          const answer = (typeof val.answer === 'string') ? JSON.parse(val.answer) : val.answer;
          await pc.setRemoteDescription(answer);
          callStatus.textContent = `In call with ${targetName}`;
              endCallBtn.style.display = 'inline-block';
              showInCallControls(true);
              // mark call started
              callStartTime = Date.now(); savedThisCall = false;
              if(saveCallBtn) saveCallBtn.style.display = 'inline-block';
              enterCallMode();
        }catch(e){ console.error('apply answer', e); alert('Failed to connect call. Please try again.'); cleanupCall(); }
      }
      if(val.status === 'rejected'){
        closeDialingModal();
        rejectionMessage.textContent = `${targetName} declined the call`;
        rejectionModal.style.display = 'flex';
        cleanupCall();
      }
      if(val.status === 'ended'){
        closeDialingModal();
        callStatus.textContent = `Call ended`;
        cleanupCall();
      }
    });
  }catch(e){ console.error('initiate failed', e); alert('Failed to place call: ' + e.message + '. Please check your connection and permissions.'); cleanupCall(); closeDialingModal(); }
}

// Resolve a 5-digit number to a target display name then call
async function initiateCallByNumber(number, isVideo){
  const n = (number||'').trim();
  if(!/^[0-9]{5}$/.test(n)) return alert('Enter a valid 5-digit number');
  try{
    const numSnap = await get(ref(db, 'numbers/' + n));
    if(!numSnap.exists()) return alert('Number not found');
    const key = numSnap.val();
    // fetch the user entry to read the display name
    const userSnap = await get(ref(db, 'users/' + key));
    if(!userSnap.exists()) return alert('User not found for that number');
    const user = userSnap.val();
    if(!user.online) return alert('User appears offline');
    // user.name contains display name
    await initiateCall(user.name, isVideo);
    // ensure logs listener is active for current user
    startListeningLogs();
  }catch(e){ console.error('dial by number failed', e); alert('Dial failed: ' + e); }
}

// --- WebRTC helpers ---
function makePeerConnection(){
  pc = new RTCPeerConnection(pcConfig);
  pc.ontrack = (ev)=>{
    console.log('Received tracks', ev.streams[0]);
    if(ev.streams && ev.streams[0]) remoteVideo.srcObject = ev.streams[0];
    else {
      const ms = new MediaStream(); ev.track && ms.addTrack(ev.track); remoteVideo.srcObject = ms;
    }
    // show remote video when we receive tracks
    setIdle(false);
    // show local preview now that call is connected
    try{ localPreview.style.display = 'block'; }catch(e){}
    // try to play the video
    remoteVideo.play().catch(e => console.log('Play failed', e));
  };
  pc.oniceconnectionstatechange = ()=>{
    console.log('ICE', pc.iceConnectionState);
    if(pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed'){
      cleanupCall();
    }
  };
  // start signal monitoring for this peer connection only if signal UI is visible (Dial page)
  try{
    const sigWrap = document.querySelector('.signalWrapper');
    if(sigWrap && sigWrap.style.display !== 'none') startSignalMonitor(pc);
  }catch(e){ console.warn('startSignalMonitor failed', e); }
}

function waitForIceGatheringComplete(pc){
  return new Promise((resolve)=>{
    if(pc.iceGatheringState === 'complete') return resolve();
    function check(){ if(pc.iceGatheringState === 'complete'){ pc.removeEventListener('icegatheringstatechange', check); resolve(); } }
    pc.addEventListener('icegatheringstatechange', check);
    pc.addEventListener('icecandidate', (ev)=>{ if(!ev.candidate) resolve(); }, {once:true});
  });
}

// --- Call logging helpers ---
async function saveCallEntry(entry){
  try{
    const myKey = getMyKey();
    if(!myKey) return;
    // try to resolve peer's number (if peer is a username stored in /users)
    try{
      if(entry.peer){
        const peerKey = entry.peer.replace(/[.#\[\]]/g,'_');
        const userSnap = await get(ref(db, 'users/' + peerKey));
        if(userSnap && userSnap.exists()){
          const u = userSnap.val();
          entry.peerNumber = u.number || entry.peerNumber || null;
          entry.peerName = u.name || entry.peer;
        } else {
          // still store peerName for convenience
          entry.peerName = entry.peer;
        }
      }
    }catch(e){ console.warn('peer resolution failed', e); }
  // determine a stable session id so we don't create duplicates
  let sessionId = null;
  try{ sessionId = (currentSessionRef && currentSessionRef.key) || null; }catch(e){}
  if(!sessionId){ sessionId = 'sess-' + (entry.startedAt || Date.now()) + '-' + Math.random().toString(36).slice(2,8); }
  // include sessionId in the entry
  entry.sessionId = sessionId;
  // write under a stable key (set) to avoid duplicate pushes
  await set(ref(db, 'logs/' + myKey + '/' + sessionId), entry);
    // attempt to add to peer's logs (reverse direction)
    if(entry.peer){
      try{
        const peerKey = entry.peer.replace(/[.#\[\]]/g,'_');
        const peerEntry = Object.assign({}, entry, { peer: myName || 'unknown', peerNumber: null, peerName: myName || 'You', direction: entry.direction === 'outgoing' ? 'incoming' : 'outgoing', sessionId });
        await set(ref(db, 'logs/' + peerKey + '/' + sessionId), peerEntry);
      }catch(e){ console.warn('failed to write peer log', e); }
    }
  }catch(e){ console.error('saveCallEntry failed', e); }
}

// fetch logs once (for immediate refresh)
async function fetchLogsOnce(){
  const key = getMyKey(); if(!key) return {};
  try{ const snap = await get(ref(db, 'logs/' + key)); return snap.val() || {}; }catch(e){ return {}; }
}

function renderLogsList(logs){
  if(!callLogsDiv) return;
  callLogsDiv.innerHTML = '';
  const keys = Object.keys(logs || {});
  if(keys.length === 0){ callLogsDiv.textContent = 'No calls yet'; return; }
  // sort by startedAt desc
  const items = keys.map(k=> logs[k]).sort((a,b)=> (b.startedAt||0) - (a.startedAt||0));
  for(const it of items){
    const row = document.createElement('div'); row.style.padding='8px 0'; row.style.borderBottom='1px solid rgba(255,255,255,0.02)';
    const d = new Date(it.startedAt||Date.now());
    const dur = it.duration ? Math.round((it.duration/1000)) + 's' : '-';
    // build content
    const title = document.createElement('div'); title.style.fontWeight='600';
    const peerLabel = document.createElement('span'); peerLabel.textContent = it.peerName || it.peer || 'Unknown';
    const meta = document.createElement('span'); meta.className='small muted'; meta.style.marginLeft='8px'; meta.textContent = `${it.media||''} • ${it.direction}`;
    title.appendChild(peerLabel); title.appendChild(meta);
    const sub = document.createElement('div'); sub.className='small muted'; sub.textContent = `${d.toLocaleString()} • ${dur}`;
    row.appendChild(title); row.appendChild(sub);
    // add action button: if this peer is not in our contacts, show Add button (requires peerNumber)
    const actions = document.createElement('div'); actions.style.marginTop='6px';
    if(it.peerNumber && (!contactsMap || !Object.prototype.hasOwnProperty.call(contactsMap, String(it.peerNumber)))){
      const addBtn = document.createElement('button'); addBtn.textContent = 'Add to contacts'; addBtn.style.marginLeft='6px'; addBtn.style.borderRadius='8px'; addBtn.style.padding='6px 8px'; addBtn.onclick = ()=>{ addContact(it.peerNumber, it.peerName || it.peer); };
      actions.appendChild(addBtn);
    } else if(!it.peerNumber){
      // try to resolve by name and show Resolve button
      const resBtn = document.createElement('button'); resBtn.textContent = 'Resolve & Add'; resBtn.style.marginLeft='6px'; resBtn.style.borderRadius='8px'; resBtn.style.padding='6px 8px';
      resBtn.onclick = async ()=>{
        if(!it.peer) return alert('No peer name available');
        const key = it.peer.replace(/[.#\[\]]/g,'_');
        const snap = await get(ref(db,'users/' + key));
        if(snap && snap.exists()){
          const u = snap.val();
          await addContact(u.number, u.name);
          alert('Contact added');
        }else{
          alert('User not found in directory');
        }
      };
      actions.appendChild(resBtn);
    }
    row.appendChild(actions);
    callLogsDiv.appendChild(row);
  }
}

function startListeningLogs(){
  const key = getMyKey(); if(!key) return;
  const logsRef = ref(db, 'logs/' + key);
  onValue(logsRef, (snap)=>{ renderLogsList(snap.val() || {}); });
}

// clear call history for current user
async function clearCallHistory(){
  if(!confirm('Clear all call history for your account? This cannot be undone.')) return;
  const key = getMyKey(); if(!key) return alert('Sign in first');
  try{
    await set(ref(db, 'logs/' + key), null);
    // refresh UI
    renderLogsList({});
    alert('Call history cleared');
  }catch(e){ console.error('clear history failed', e); alert('Failed to clear history'); }
}
if(clearHistoryBtn) clearHistoryBtn.onclick = ()=> clearCallHistory();

function showLocalPreview(stream){
  if(!stream) return;
  // store the local stream and defer showing it until call is connected
  localStream = stream;
  localPreviewVideo.srcObject = stream;
  // ensure audio tracks follow current mute state
  try{ for(const t of stream.getAudioTracks()) t.enabled = !audioMuted; }catch(e){}
  // don't show preview yet — it will be made visible when remote video arrives (setIdle(false))
}

endCallBtn.onclick = async ()=>{
  if(!currentSessionRef) return;
  try{
    await update(currentSessionRef, { status: 'ended', endedAt: Date.now() });
  }catch(e){ console.error(e); }
  cleanupCall();
};

async function cleanupCall(){
  try{
    // save call log if we have metadata and it wasn't already saved
    if(currentCallMeta && !savedThisCall){
      const endedAt = Date.now();
      const startedAt = callStartTime || endedAt;
      const duration = callStartTime ? (endedAt - callStartTime) : 0;
      const entry = { peer: currentCallMeta.peer, direction: currentCallMeta.direction, media: currentCallMeta.media, startedAt, endedAt, duration };
      await saveCallEntry(entry);
      savedThisCall = true; lastCallSummary = entry;
      // refresh UI
      if(callLogsDiv){ const logs = await fetchLogsOnce(); renderLogsList(logs); }
    }
  }catch(e){ console.error('error saving call log on cleanup', e); }

  // stop monitoring signal
  try{ stopSignalMonitor(); }catch(e){}
  if(pc){ try{ pc.close(); }catch(e){} pc = null; }
  if(localStream){ for(const t of localStream.getTracks()) t.stop(); localStream = null; }
  remoteVideo.srcObject = null;
  localPreview.style.display = 'none';
  localPreviewVideo.srcObject = null;
  currentSessionRef = null;
  endCallBtn.style.display = 'none';
  // hide in-call overlay controls
  showInCallControls(false);
  // hide quicksave
  if(saveCallBtn) saveCallBtn.style.display = 'none';
  // reset call state
  currentCallMeta = null; callStartTime = null; savedThisCall = false;
  // exit call mode
  exitCallMode();
  // return to idle UI
  setIdle(true);
  // close any open modals
  closeDialingModal();
}

</script>
<script>
// Register service worker for PWA
let swRegistration = null;
let deferredPrompt = null;

window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
});

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js')
    .then(reg => {
      swRegistration = reg;
      console.log('Service Worker registered');
    })
    .catch(err => console.log('Service Worker registration failed', err));
}

function showNotification(title, options = {}) {
  if (swRegistration) {
    swRegistration.showNotification(title, options);
  } else if ('Notification' in window && Notification.permission === 'granted') {
    new Notification(title, options);
  }
}

// Clear caches, service worker, storage, and cookies
async function clearAppData(){
  try{
    // Unregister service workers
    if('serviceWorker' in navigator){
      const regs = await navigator.serviceWorker.getRegistrations();
      for(const r of regs) await r.unregister();
    }
    // Clear caches
    if('caches' in window){
      const keys = await caches.keys();
      await Promise.all(keys.map(k => caches.delete(k)));
    }
    // Clear local/session storage
    try{ localStorage.clear(); sessionStorage.clear(); }catch(e){}
    // Clear cookies (best-effort for same-site cookies)
    try{
      document.cookie.split(';').forEach(function(c){
        const eqPos = c.indexOf('=');
        const name = eqPos > -1 ? c.substr(0, eqPos).trim() : c.trim();
        if(name) document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/';
      });
    }catch(e){}
    alert('Cache, service worker and local data cleared. The app will reload.');
    setTimeout(()=> location.reload(true), 300);
  }catch(e){ console.error('clearAppData failed', e); alert('Failed to clear app data: ' + e.message); }
}

function installApp() {
  if (deferredPrompt) {
    deferredPrompt.prompt();
    deferredPrompt.userChoice.then((choiceResult) => {
      if (choiceResult.outcome === 'accepted') {
        console.log('User accepted the install prompt');
      }
      deferredPrompt = null;
    });
  } else {
    alert('App is already installed or install prompt not available.');
  }
}
</script>

<!-- Notification & unread-count client logic -->
<script>
// Simple client-side notification / unread counter system
(() => {
  const notifBadge = document.getElementById('notifBadge');
  const notifBell = document.getElementById('notifBell');
  const messagesList = document.getElementById('messagesList');
  const messengerContacts = document.getElementById('messengerContacts');
  const chatWithEl = document.getElementById('chatWith');

  const state = {
    unreadTotal: 0,
    unreadByContact: {}, // contactId -> count
  };

  function updateNotifBadge(){
    if(!notifBadge) return;
    // prefer DB-driven unreadCounts if available
    let n = 0;
    try{ if(typeof unreadCounts !== 'undefined' && unreadCounts){ n = Object.values(unreadCounts).reduce((a,b)=> a + (Number(b)||0), 0); } else if(state && state.unreadTotal) { n = state.unreadTotal; } }catch(e){ n = (state && state.unreadTotal) || 0; }
    if(n > 0){ notifBadge.style.display = 'inline-flex'; notifBadge.textContent = n > 99 ? '99+' : String(n); }
    else notifBadge.style.display = 'none';
  }

  async function requestNotificationPermission(){
    if(!('Notification' in window)) return;
    if(Notification.permission === 'default'){
      try{ await Notification.requestPermission(); }catch(e){ /* ignore */ }
    }
  }

  function showBrowserNotif(title, body){
    try{
      if(window.showNotification) { // service worker helper from page
        showNotification(title, { body, icon: undefined });
      } else if('Notification' in window && Notification.permission === 'granted'){
        new Notification(title, { body });
      }
    }catch(e){ console.warn('notify failed', e); }
  }

  // Call this to simulate an incoming message for testing
  window.simulateIncoming = async function(fromId = 'alice', fromDisplay = 'Alice', text = 'Hello!'){
    // If DB is available, write to messages/private so listeners compute unread counts
    try{
      if(typeof db !== 'undefined' && typeof ref === 'function' && typeof push === 'function' && typeof set === 'function'){
        const myKey = (typeof getMyKey === 'function') ? getMyKey() : 'local';
        // simulate message written under a two-way chat id (sorted ids)
        const chatId = fromId === myKey ? myKey + '_' + fromId : [fromId, myKey].sort().join('_');
        const msgRef = push(ref(db, 'messages/private/' + chatId));
        await set(msgRef, { from: fromId, fromDisplay: fromDisplay, text: text, ts: Date.now() });
        return;
      }
    }catch(e){ console.warn('simulateIncoming write failed', e); }
    // fallback: update UI locally
    handleIncomingMessage(fromId, fromDisplay, text);
  };

  function openChat(contactId, displayName){
    // set header
    try{ if(chatWithEl) chatWithEl.textContent = displayName || contactId; }catch(e){}
    try{ const chatAvatar = document.getElementById('chatAvatar'); if(chatAvatar) chatAvatar.textContent = (displayName||'?').charAt(0).toUpperCase(); }catch(e){}
    // show only messages for this contact
    if(messagesList){
      const rows = messagesList.querySelectorAll('.msg-row');
      rows.forEach(r => { r.style.display = (r.dataset.from === contactId) ? '' : 'none'; });
      // auto-scroll
      messagesList.scrollTop = messagesList.scrollHeight;
    }
    // mark as read locally and in DB
    try{
      // mark as seen locally so UI updates immediately
      seenTimestamps[contactId] = Date.now();
      saveSeenTimestamps();
      // clear computed unreadCounts for this chat and update UI (if function present)
      try{ if(typeof updateAllContactBadges === 'function') updateAllContactBadges(); if(typeof updateGlobalBadge === 'function') updateGlobalBadge(); }catch(e){}
      // also write seen timestamp to DB so other clients know we've read messages
      try{
        const myKey = (typeof getMyKey === 'function') ? getMyKey() : null;
        if(myKey && typeof ref === 'function' && typeof set === 'function' && typeof db !== 'undefined'){
          set(ref(db, 'messages/seen/' + myKey + '/' + contactId), Date.now()).catch(()=>{});
        }
      }catch(e){ console.warn('failed to write seen ts to db', e); }
    }catch(e){ console.warn('openChat mark read failed', e); }
  }

  function ensureContactElement(contactId, displayName){
    if(!messengerContacts) return null;
    let btn = messengerContacts.querySelector('[data-contact-id="' + contactId + '"]');
    if(btn) return btn;
    // create a simple contact button entry
    btn = document.createElement('button');
    btn.className = 'messengerContactBtn';
    btn.setAttribute('data-contact-id', contactId);
    btn.style.display = 'flex'; btn.style.alignItems='center'; btn.style.justifyContent='space-between'; btn.style.gap='8px'; btn.style.padding='8px'; btn.style.width='100%'; btn.style.border='0'; btn.style.background='transparent'; btn.style.color='inherit'; btn.style.borderRadius='8px';
    const left = document.createElement('div'); left.style.display='flex'; left.style.gap='8px'; left.style.alignItems='center';
    const avatar = document.createElement('div'); avatar.className='avatar-small'; avatar.textContent = (displayName||contactId).charAt(0).toUpperCase(); avatar.style.width='44px'; avatar.style.height='44px'; avatar.style.borderRadius='50%'; avatar.style.display='flex'; avatar.style.alignItems='center'; avatar.style.justifyContent='center'; avatar.style.fontWeight='700';
    const meta = document.createElement('div'); meta.className='contact-meta'; const name = document.createElement('div'); name.className='contact-name'; name.textContent = displayName || contactId; const sub = document.createElement('div'); sub.className='contact-sub muted'; sub.textContent = 'New message'; meta.appendChild(name); meta.appendChild(sub);
    left.appendChild(avatar); left.appendChild(meta);
    btn.appendChild(left);
    // badge placeholder
    const right = document.createElement('div'); right.style.display='flex'; right.style.alignItems='center'; right.style.gap='8px'; btn.appendChild(right);
    messengerContacts.insertBefore(btn, messengerContacts.firstChild);
    // click opens chat
    btn.addEventListener('click', ()=> openChat(contactId, displayName));
    return btn;
  }

  function handleIncomingMessage(fromId, fromDisplay, text){
    // Create message DOM (their message)
    if(messagesList){
      const row = document.createElement('div'); row.className = 'msg-row'; row.dataset.from = fromId; row.dataset.unread = 'true';
      const bubble = document.createElement('div'); bubble.className = 'msg-bubble their'; bubble.textContent = text;
      const meta = document.createElement('div'); meta.className = 'msg-meta'; meta.textContent = `${fromDisplay} • ${new Date().toLocaleTimeString()}`;
      row.appendChild(bubble); row.appendChild(meta);
      messagesList.appendChild(row);
      // auto-scroll
      messagesList.scrollTop = messagesList.scrollHeight;
    }

    // increment unread counters (unless the chat is currently open with this user)
    const currentChatName = chatWithEl && chatWithEl.textContent && chatWithEl.textContent.trim();
    if(currentChatName !== fromDisplay){
      state.unreadByContact[fromId] = (state.unreadByContact[fromId] || 0) + 1;
      state.unreadTotal = Object.values(state.unreadByContact).reduce((a,b) => a + b, 0);
      updateNotifBadge();
      // ensure contact exists and update badge
      try{
        let btn = ensureContactElement(fromId, fromDisplay);
        if(btn){ let b = btn.querySelector('.contact-badge'); if(!b){ b = document.createElement('span'); b.className='contact-badge'; btn.appendChild(b); } b.textContent = state.unreadByContact[fromId]; }
      }catch(e){}
      // show browser notification
      showBrowserNotif(`New message from ${fromDisplay}`, text);
    } else {
      // message arrived in the currently visible chat -> mark appended as read (no badge)
      if(messagesList){ const rows = messagesList.querySelectorAll('.msg-row'); rows.forEach(r => { if(r.dataset.from === fromId) r.dataset.unread='false'; }); }
    }
  }

  function markChatRead(contactId){
    if(!contactId) return;
    try{
      // update local seen timestamp and persist
      seenTimestamps[contactId] = Date.now();
      saveSeenTimestamps();
      // also clear unreadCounts entry if present
      try{ if(typeof unreadCounts !== 'undefined' && unreadCounts && unreadCounts[contactId]){ unreadCounts[contactId] = 0; } }catch(e){}
      // update notifications UI using existing helpers
      try{ if(typeof updateContactBadge === 'function') updateContactBadge(contactId); if(typeof updateGlobalBadge === 'function') updateGlobalBadge(); }catch(e){}
      // remove badge from contact UI (fallback)
      try{ const btn = messengerContacts && messengerContacts.querySelector('[data-contact-id="' + contactId + '"]'); if(btn){ const b = btn.querySelector('.contact-badge'); if(b) b.remove(); } }catch(e){}
      // mark messages in the list as read
      if(messagesList){ const rows = messagesList.querySelectorAll('.msg-row'); rows.forEach(r=>{ if(r.dataset.from === contactId) r.dataset.unread='false'; }); }
      // write seen timestamp to DB so other clients know messages were read
      try{
        const myKey = (typeof getMyKey === 'function') ? getMyKey() : null;
        if(myKey && typeof ref === 'function' && typeof set === 'function' && typeof db !== 'undefined'){
          set(ref(db, 'messages/seen/' + myKey + '/' + contactId), Date.now()).catch(()=>{});
        }
      }catch(e){ console.warn('failed to write seen ts to db', e); }
    }catch(e){ console.warn('markChatRead failed', e); }
  }

  function markAllRead(){
    try{
      // update local state
      seenTimestamps = seenTimestamps || {};
      const now = Date.now();
      // mark all as seen locally
      Object.keys(unreadCounts || {}).forEach(k => { seenTimestamps[k] = now; if(unreadCounts) unreadCounts[k] = 0; });
      saveSeenTimestamps();
      // update UI
      try{ if(typeof updateAllContactBadges === 'function') updateAllContactBadges(); if(typeof updateGlobalBadge === 'function') updateGlobalBadge(); }catch(e){}
      try{ messengerContacts && messengerContacts.querySelectorAll('.contact-badge').forEach(b=>b.remove()); }catch(e){}
      if(messagesList){ messagesList.querySelectorAll('.msg-row').forEach(r=> r.dataset.unread='false'); }
      // write seen timestamps to DB for each chat so other clients are notified
      try{
        const myKey = (typeof getMyKey === 'function') ? getMyKey() : null;
        if(myKey && typeof ref === 'function' && typeof set === 'function' && typeof db !== 'undefined'){
          const writePromises = Object.keys(seenTimestamps || {}).map(cid => set(ref(db, 'messages/seen/' + myKey + '/' + cid), seenTimestamps[cid]));
          Promise.all(writePromises).catch(()=>{});
        }
      }catch(e){ console.warn('failed to write seen timestamps to db', e); }
    }catch(e){ console.warn('markAllRead failed', e); }
  }

  // notification panel behavior
  const notifPanel = document.getElementById('notifPanel');
  const notifList = document.getElementById('notifList');
  const notifClearAll = document.getElementById('notifClearAll');

  function renderNotifPanel(){
    if(!notifList) return;
    // prefer server-computed unreadCounts if available
    const source = (typeof unreadCounts !== 'undefined' && unreadCounts) ? unreadCounts : (state && state.unreadByContact ? state.unreadByContact : {});
    const entries = Object.keys(source || {});
    if(entries.length === 0){ notifList.textContent = 'No notifications'; return; }
    notifList.innerHTML = '';
    for(const id of entries){
      const count = source[id] || 0;
      const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center'; row.style.padding='8px'; row.style.borderBottom='1px solid rgba(255,255,255,0.03)';
      const left = document.createElement('div'); left.textContent = id; left.style.fontWeight='600';
      const right = document.createElement('div'); right.style.display='flex'; right.style.alignItems='center'; right.style.gap='8px';
      const c = document.createElement('span'); c.className='contact-badge'; c.textContent = count;
      const openBtn = document.createElement('button'); openBtn.textContent = 'Open'; openBtn.style.border=0; openBtn.style.background='transparent'; openBtn.style.color='inherit'; openBtn.style.cursor='pointer';
      const _openHandler = function(){
        if(messengerContacts){ try{ document.querySelector("[data-target='messenger']").click(); }catch(e){} }
        openChat(id, id);
        if(notifPanel) notifPanel.style.display='none';
      };
      openBtn.addEventListener('click', _openHandler);
      right.appendChild(c); right.appendChild(openBtn);
      row.appendChild(left); row.appendChild(right);
      notifList.appendChild(row);
    }
  }

  if(notifBell){ notifBell.addEventListener('click', ()=>{ if(!notifPanel) return; notifPanel.style.display = (notifPanel.style.display === 'none' || !notifPanel.style.display) ? 'block' : 'none'; renderNotifPanel(); }); }
  if(notifClearAll){ notifClearAll.addEventListener('click', ()=>{ markAllRead(); renderNotifPanel(); if(notifPanel) notifPanel.style.display='none'; }); }

  // listen for clicks on contacts to mark that contact read when opened
  if(messengerContacts){
    messengerContacts.addEventListener('click', (ev)=>{
      const btn = ev.target.closest('.messengerContactBtn');
      if(!btn) return;
      const cid = btn.dataset.contactId || btn.getAttribute('data-contact-id') || btn.textContent.trim();
      if(cid) markChatRead(cid);
    });
  }

  // Request permission on load
  requestNotificationPermission().catch(()=>{});

  // expose small API for other scripts
  window.__appNotifications = { handleIncomingMessage, markChatRead, markAllRead, state };
  // expose badge updater so DB-driven listeners can call it
  try{ window.updateNotifBadge = updateNotifBadge; }catch(e){}

})();
</script>
</body>
</html>